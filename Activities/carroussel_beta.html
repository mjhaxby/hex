<!--*HEX SETTINGS START*
  {
    "cols_min":1,
    "cols_max":5,
    "rows_min":1,
    "cols":[{"title":"Front","text":true,"image":true},{"title":"Back","text":true,"image":true},{"title":"Show from","text":false,"image":false,"datetime":true},{"title":"Show until","text":false,"image":false,"datetime":true},"Category"],
    "description": "For displaying images or information. Items can be shown from and until specific dates. The parameter columns allows items to be shown according to the URL parameter `show`. If no parameter is given, all items will be shown.",
    "markdown_support":true,
    "empty_cells_allowed":true,
    "settings":[                
        {"name":"color","label":"Color","type":"select","options":["Default Light", "Default Dark","Lille","university","B5 4eva","bridge of wood","Black and white","Dark mode"]},
        {"name":"font","label":"Font","type":"font_family","var":"main-font"},
        {"name":"fontSize","label":"Font size (%)","type":"number","min":1,"max":500,"default":100},
        {"name":"autoAdjustFontSize","label":"Automatically adjust font size","type":"checkbox","default":true},
        {"name":"border","label":"Border","type":"select","options":["none","hairline","thick","rounded"]},
        {"name":"logo","label":"Show logo","type":"select-import","options":["None","hex"],"dependents":[
          {"name":"logoLink","disable":"None"}
        ]},        
        {"name":"logoLink","label":"Logo links to","type":"text","info":"Provide a URL for the logo to link to."},
        {"name":"header","label":"Header","type":"text"},
        {"name":"footer","label":"Footer","type":"text"},
        {"name":"backMode","label":"Back display","type":"select","options":["Flip","Show underneath on click","Always show underneath","Disabled"],"optionValues":["flip","under","autoUnder","disabled"]},
        {"name":"sort","label":"Sort order","type":"select","options":["Index","Front text","Back text","Date (from, then until)","Date (until, then from)","Random"],"optionValues":["index","front","back","from","until","random"]},
        {"name":"invertSort","label":"Invert sort order","type":"checkbox","default":false},
        {"name":"navigation","label":"Allow navigation","type":"checkbox","default":"true","info":"User can click on items to navigate the display. If navigation, random picker and auto advance are all disabled, the carroussel will not move."},
        {"name":"picker","label":"Random picker","type":"checkbox","default":false,"info":"User can press a button to display an item at random. If navigation, random picker and auto advance are all disabled, the carroussel will not move.","dependents":[
            {"name":"pickerText","enable":true},{"name":"randomSequence","enable":true}
        ]},
        {"name":"pickerText","label":"Picker button text","type":"text","default":"Random"},
        {"name":"randomSequence","label":"Pick all items before reshuffling","type":"checkbox","default":true,"info":"If enabled, all items will be shown once before any are repeated. If disabled, a truly random item is chosen each time, excluding the current item."},
        {"name":"autoAdvance","label":"Auto advance","type":"checkbox","default":true,"dependents":[
            {"name":"autoAdvanceDelay","enable":true}
        ]},
        {"name":"autoAdvanceDelay","label":"Auto advance delay (s)","type":"number","default":5,"min":1},
        {"name":"openLink","label":"Back is hyperlink","type":"checkbox","default":false,"info":"When enabled, instead if showing the back of an item, this will open a URL given in the ‘Back’ column. If no URL is provided, the back will be shown as set."},
        {"name":"category","label":"Category filter","type":"text","info":"Only show items that match the category name in the fifth column. If the category column is not filled, it will always be shown."}
    ]
}
*HEX SETTINGS END*-->
<html>
<head>
  <meta charset="UTF-8">
  <title>Carroussel</title>
  <style>        
          :root {
            --bg-color: #F2F3EB;
            --fg-color: #bc5d31;
            --front-border: #FFCAB1;
            --back-border: #bc5d31;
            --back-bg: #FFCAB1;
            --back-fg: #000000;
            --front-bg: #C1D7AE;
            --front-fg: #000000;
            --highlight: #8CC084;
            --header-height: 0px;
            --vertical-height: 0px;
        }

        [data-theme="default dark"] {
            --bg-color: #2E4057;
            --fg-color: #F6D8AE;
            --front-border: #425c7f;
            --back-border: #F6D8AE;
            --back-bg: #2E4057;
            --back-fg: #F6D8AE;
            --front-bg: #F6D8AE;
            --front-fg: #2E4057;
            --highlight: #FFCAB1;
        }

        [data-theme="black and white"] {
            --bg-color: #ffffff;
            --bg-color-light: #747474;
            --fg-color: #000000;
            --back-bg: #000000;
            --back-fg: #ffffff;
            --back-border: #747474;
            --front-bg: #ffffff;
            --front-fg: #000000;
            --front-border: #747474;            
            --highlight: #747474;
        }

        [data-theme="lille"] {
          --bg-color: #FFFFFF;
          --fg-color: #002D2D;
          --front-border: #5862ed;
          --back-border: #002D2D;
          --back-fg: #FFFFFF;
          --back-bg: #002D2D;          
          --front-fg: #002D2D;
          --front-bg: #FFFFFF;
          --highlight: #5862ed;
        }

        [data-theme="university"] {
          --bg-color: #FFFFFF;
          --fg-color: #002D2D;
          --front-border: #002D2D;
          --back-border: #002D2D;
          --back-fg: #002D2D;
          --front-fg: #002D2D;
          --back-bg: #FAF0E1;
          --front-bg: #FAF0E1;
          --highlight: #FC535C;
        }

        [data-theme="dark mode"] {
          --bg-color: #000000;
          --fg-color: #FFFFFF;
          --front-border: #FFFFFF;
          --back-border: #FFFFFF;
          --back-bg: #1d1d1d;
          --back-fg: #FFFFFF;
          --front-bg: #1d1d1d;
          --front-fg: #FFFFFF;
          --highlight: #FFFFFF;
        }

        [data-theme="b5 4eva"] {
          --bg-color: #FFFFFF;
          --fg-color: #fc535c;
          --front-border: #fc535c;
          --back-border: #ffd24b;
          --back-fg: #2D0505;
          --front-fg: #fc535c;
          --back-bg: #fc535c;
          --front-bg: #ffd24b;
          --highlight: #5862ED;
        }

        [data-theme="bridge of wood"] {
          --bg-color: #FFFFFF;
          --fg-color: #ff6941;
          --front-border: #ffb4d2;
          --back-border: #ffb4d2;
          --back-bg: #ff6941;
          --back-fg: #FFFFFF;
          --front-bg: #7abaff;
          --front-fg: #FFFFFF;
          --highlight: #ffb4d2;
        }

        /* [data-header="header"] {
          --header-height: 20px;
        }

        [data-footer="footer"] {
          --footer-height: 20px;
        } */
        
        
        body {
      font-family: var(--main-font);
      overflow: hidden;
      /* font-size: 0.75em; */
      background-color: var(--bg-color);
      color: var(--fg-color);
    }



    a{
      color: var(--highlight);
      font-weight: bold;
      text-decoration: none;
    }

    a:hover{
      text-decoration: underline dotted;
    }

    /* img,
    .text {
      -webkit-backface-visibility: hidden;
      backface-visibility: hidden;
    } */

    button {
      background: none;
      border: none;
      opacity: 50%;
      transition: opacity 300ms, transform 300ms;
      font-family: inherit;
      color: inherit;
    }

    .border-rounded button{
      border-radius: 2vh;
    }

    button:hover, button:focus {
      opacity: 100%;      
    }    

    button:focus{
      outline: var(--highlight) solid 3px;
    }

    code {
      user-select: text;
    }

        .has-header{
      --header-height: 20px;
    }

    .has-footer{
      --footer-height: 20px;
    }

    .header{
      height: var(--header-height);
      font-size: 0.5em;
    }    

    .footer{
      height: var(--footer-height);
    }

    .header, .footer{
        font-size: 0.5em;
        text-align: center;
        width: 100vw;
    }

    .logo{
      position: absolute;
      bottom: 5;
      right: 5;
      width: 50px;
      z-index: 9999999;
      opacity: 0.5;
      pointer-events: none;
      z-index: 99999;
      transition: filter 300ms, opacity 300ms;
    }

    .logo img, .logo svg{
      filter:saturate(0)
    }

    .logo:hover img, .logo:hover svg{
      filter:none;
    }

    .logo-link{
      pointer-events: all;
    }

    .logo.logo-link:hover{
      opacity: 1;
    }

    .pick-button {
      position: absolute;
      bottom: 10;
      left: 50%;
      transform: translate(-50%);
      z-index: 999999;
    }

    .fade {
      position: fixed;
      top: 0;
      width: 10em;
      max-width: 7.5vw;
      height: 100vh;
      pointer-events: none;
      /* Allows interaction with elements underneath */
      z-index: 9999;
      /* Ensures it's in front of everything */
    }

    .fade-left {
      left: 0;
      background: linear-gradient(to right, var(--bg-color) 0%, rgba(255, 255, 255, 0) 100%);
    }

    .fade-right {
      right: 0;
      background: linear-gradient(to left, var(--bg-color) 0%, rgba(255, 255, 255, 0) 100%);
    }


    .splide__arrows {
      position: absolute;
      top: 50%;
      width: 100vw;
      height: 5vh;
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: none;
      pointer-events: none;
      z-index: 99999;
      fill: var(--fg-color);
    }

    .splide__arrows button{
      pointer-events: all;
    }

    .splide__arrows button:focus {
      outline: none;
      opacity: 1;
    }

    .splide__arrows button:focus svg {
      outline: 3px solid var(--highlight);
      outline-offset: 3px;
    }

    .splide__arrows svg {
      transform: scale(0.5);
      border: none !important;
    }

    .splide__arrow--prev {
      transform: rotate(180deg);      
    }

    .splide__arrow--prev:active {
      transform: translateX(-5px) rotate(180deg);
    }

    .splide__arrow--next:active {
      transform: translateX(5px);
    }

    button.splide__pagination__page{
      background: var(--fg-color);
      opacity: 0.5;
    }

    button.splide__pagination__page.is-active{
      background: var(--fg-color);
      opacity: 1;
    }


    .display-item {
      text-align: center;
      width: 10vw;
      min-width: 100px;
      height: 75vh;
      transition: transform 800ms ease-in-out, left 800ms ease-in-out, opacity 800ms ease-in-out, width 800s;
      perspective: 800px;

      /* border: 2px solid blue;           */
    }

    .display-item img,
    .display-item svg,
    .display-item .text {
      transition: transform 800ms ease-in-out, opacity 800ms ease-in-out, border 800ms;
      max-height: 75vh;
      max-width: 90vw;
    }

    .display-item svg{
      height: 75vh;
    }

    .display-item .card {
      position: absolute;
      margin-top: 5vh;
      margin-bottom: 5vh;
      /* width: 30vw; */
      transform: translate(-50%);
      transform-origin: center; /* Add this */
      transform-style: preserve-3d; /* Add this */

      /* border: 1px solid red; */
    }

    .display-item:focus {
      outline: none;
    }

    .display-item:focus img,
    .display-item:focus svg,
    .display-item:focus .text-only {
      outline: 3px solid var(--highlight);
      outline-offset: 3px
    }

    .under:focus .back.text-only{
      outline: none;
    }

    .inner-container {
      transition: transform 800ms ease-in-out;
      /* display: inline-block; */
    }

    .left .inner-container {
      transform: translateX(-200%);
    }

    .right .inner-container {
      transform: translateX(200%);
    }

    .display-item .face,
    .display-item .card {
      perspective: 800px;
      transition: transform 800ms ease-in-out, left 800ms ease-in-out, opacity 800ms ease-in-out, border 800ms ease-in-out, width 1600ms;
      max-height: 75vh;
      transform-style: preserve-3d;
      transform-origin: center; /* Add this */
    }

    .under .card,
    .under .face,
    .under img,
    .under .text,
    .under .text {
      max-height: 60vh;      
    }  

    .text-only.front{
      background-color: var(--front-bg);
      color: var(--front-fg);
    }

    .text-only.back{
      background-color: var(--back-bg);
      color: var(--back-fg);
    }

    .text-only {
      display: inline-flex;
      /* position: relative; */
      aspect-ratio: 2 / 3;
      align-content: space-around;
      align-items: center;
      justify-items: center;
      justify-content: center;
      padding-top: 1vh;
      padding-bottom: 1vh;
      overflow: scroll;
      flex-wrap: wrap;
    }

    .text {
      margin: 2em;
      user-select:text;
    }

    .text li{
      text-align: left;
    }

    .left .face {
      transform: translate(-50%) rotate3d(0, 1, 0, 60deg) scale(0.66);
    }

    .right .face {
      transform: translate(-50%) rotate3d(0, 1, 0, -60deg) scale(0.66);
    }

    .left .face:hover,
    .left:focus .face {
      transform: translate(-50%) rotate3d(0, 1, 0, 50deg) scale(0.7);
    }

    .right .face:hover,
    .right:focus .face {
      transform: translate(-50%) rotate3d(0, 1, 0, -50deg) scale(0.7);
    }

    .card {
      position: relative;
      height: 75vh;
      /* transform: translate(-50%); */

      /* for testing: */
      /* border: 2px red solid; */
    }

    .face {
      position: absolute;
      top: 0;
      left: 50%;
      height: 75vh;
      /* max-width: 90vw; */
      /* width: fit-content; */
      -webkit-backface-visibility: hidden;
      backface-visibility: hidden;
      transform: translateX(-50%);

      /* for testing */
      /* border: 2px green solid; */
    }


    .flip.right .back.face,
    .flip.left .back.face {
      transform: scale(0)
    }

    .flip.up.is-active .card {
      /* transform: rotate3d(1, -1, 0, 0deg); */
      transform: translate(-50%) rotate3d(1, -1, 0, 0deg);
    }

    .flip.down.is-active .card {
      /* transform: rotate3d(-1, 1, 0, 180deg); */
      transform: translate(-50%) rotate3d(-1, 1, 0, 180deg);      
    }

    .under.up .back {
      opacity: 0;      
      width: 50%;
      /* transform: none; */
      /* border: none; */
    }

    .autoUnder .back{      
      transition: transform 800ms ease-in-out, left 800ms ease-in-out, opacity 1600ms ease-in-out, border 800ms ease-in-out, width 1600ms;      
    }

    .under.down .back, .under.autoUnder.current .back {
      transform: translate(-50%, 110%);
      opacity: 1;
    }

    .down .front {
      pointer-events: none;
    }

    .front {
      color: var(--front-fg);
      border-color: var(--front-border);
      z-index: 20;
    }

    .back {
      background-color: var(--back-bg);
      color: var(--back-fg);
      border-color: var(--back-border);
      z-index: 1;
    }

    .flip .back {
      transform: translate(-50%) rotate3d(1, -1, 0, 180deg);
      transform-style: preserve-3d;
    }

    .under .back, .under.autoUnder.current .back {
      width: 66vw;
      height: 40%;
      top: unset;
      bottom: 0;
    }

    .border img,
    .border svg,
    .border .text-only {
      border: 1.5vh solid var(--front-border);
    }    

    .border-rounded img,
    .border-rounded svg,
    .border-rounded .text-only,
    .border-rounded .face {
      border-radius: 2vh;
    }

    .border-hairline img,
    .border-hairline svg,
    .border-hairline .text-only {
      border: 1px solid var(--front-fg);
    }

    .border .back img, .border .back svg, .border .back.text-only{
      border-color: var(--back-border);
    }

    .border-hairline .back img, .border-hairline .back svg, .border-hairline .back.text-only{
      border-color: var(--back-border);
    }

    .hidden{
        display: none;
    }

    @media (prefers-reduced-motion) {

      .display-item .face,
      .display-item .car,
      button,
      .inner-container {
        transition: 0s;
      }

      .splide__arrow--prev:active {
        transform: rotate(180deg);
        opacity: 75%;
      }

      .splide__arrow--next:active {
        transform: none;
        opacity: 75%;
      }
    }

    #displayCase {
      /* position: absolute;             */
      /* padding: 5vh; */
      width: 100vw;
      height: calc(100vh - (var(--header-height) * 1.5) - (var(--footer-height) * 1.5));
    }    

    .splide__track {
      height: 100vh;
    }
  </style>
  <!-- splide style -->
  <style>
    @keyframes splide-loading {
      0% {
        transform: rotate(0)
      }

      to {
        transform: rotate(1turn)
      }
    }

    .splide__track--draggable {
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      -ms-user-select: none;
      user-select: none
    }

    .splide__track--fade>.splide__list>.splide__slide {
      margin: 0 !important;
      opacity: 0;
      z-index: 0
    }

    .splide__track--fade>.splide__list>.splide__slide.is-active {
      opacity: 1;
      z-index: 1
    }

    .splide--rtl {
      direction: rtl
    }

    .splide__track--ttb>.splide__list {
      display: block
    }

    .splide__container {
      box-sizing: border-box;
      position: relative
    }

    .splide__list {
      /* backface-visibility: hidden; */
      display: -ms-flexbox;
      display: flex;
      height: 100%;
      margin: 0 !important;
      padding: 0 !important
    }

    .splide.is-initialized:not(.is-active) .splide__list {
      display: block
    }

    .splide__pagination {
      -ms-flex-align: center;
      align-items: center;
      display: -ms-flexbox;
      display: flex;
      -ms-flex-wrap: wrap;
      flex-wrap: wrap;
      -ms-flex-pack: center;
      justify-content: center;
      margin: 0;
      pointer-events: none
    }

    .splide__pagination li {
      display: inline-block;
      line-height: 1;
      list-style-type: none;
      margin: 0;
      pointer-events: auto
    }

    .splide:not(.is-overflow) .splide__pagination {
      display: none
    }

    .splide__progress__bar {
      width: 0
    }

    .splide {
      position: relative;
      visibility: hidden
    }

    .splide.is-initialized,
    .splide.is-rendered {
      visibility: visible
    }

    .splide__slide {
      /* backface-visibility: hidden; */
      box-sizing: border-box;
      -ms-flex-negative: 0;
      flex-shrink: 0;
      list-style-type: none !important;
      margin: 0;
      position: relative
    }

    .splide__slide img {
      vertical-align: bottom
    }

    .splide__spinner {
      animation: splide-loading 1s linear infinite;
      border: 2px solid #999;
      border-left-color: transparent;
      border-radius: 50%;
      bottom: 0;
      contain: strict;
      display: inline-block;
      height: 20px;
      left: 0;
      margin: auto;
      position: absolute;
      right: 0;
      top: 0;
      width: 20px
    }

    .splide__sr {
      clip: rect(0 0 0 0);
      border: 0;
      height: 1px;
      margin: -1px;
      overflow: hidden;
      padding: 0;
      position: absolute;
      width: 1px
    }

    .splide__toggle.is-active .splide__toggle__play,
    .splide__toggle__pause {
      display: none
    }

    .splide__toggle.is-active .splide__toggle__pause {
      display: inline
    }

    .splide__track {
      overflow: hidden;
      position: relative;
      z-index: 0
    }
  </style>
  <!-- more splide stuff -->
  <style>
    .splide__pagination {
      bottom: .5em;
      left: 0;
      padding: 0 1em;
      position: absolute;
      right: 0;
      z-index: 1
    }

    .splide__pagination__page {
      background: #ccc;
      border: 0;
      border-radius: 50%;
      display: inline-block;
      height: 8px;
      margin: 3px;
      opacity: .7;
      padding: 0;
      position: relative;
      transition: transform .2s linear;
      width: 8px
    }

    .splide__pagination__page.is-active {
      background: #000;
      transform: scale(1.4);
      z-index: 1
    }

    .splide__pagination__page:hover {
      cursor: pointer;
      opacity: .9
    }

    .splide__pagination__page:focus-visible {
      outline: 3px solid var(--highlight);
      outline-offset: 3px
    }

    .splide__pagination--ttb {
      bottom: 0;
      display: -ms-flexbox;
      display: flex;
      -ms-flex-direction: column;
      flex-direction: column;
      left: auto;
      padding: 1em 0;
      right: .5em;
      top: 0
    }
  </style>
  <script>
    function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

    function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

    /*!
    * Splide.js
    * Version  : 4.1.2
    * License  : MIT
    * Copyright: 2022 Naotoshi Fujita
    */
    (function (global, factory) {
      typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.Splide = factory());
    })(this, function () {
      'use strict';

      var MEDIA_PREFERS_REDUCED_MOTION = "(prefers-reduced-motion: reduce)";
      var CREATED = 1;
      var MOUNTED = 2;
      var IDLE = 3;
      var MOVING = 4;
      var SCROLLING = 5;
      var DRAGGING = 6;
      var DESTROYED = 7;
      var STATES = {
        CREATED: CREATED,
        MOUNTED: MOUNTED,
        IDLE: IDLE,
        MOVING: MOVING,
        SCROLLING: SCROLLING,
        DRAGGING: DRAGGING,
        DESTROYED: DESTROYED
      };

      function empty(array) {
        array.length = 0;
      }

      function slice(arrayLike, start, end) {
        return Array.prototype.slice.call(arrayLike, start, end);
      }

      function apply(func) {
        return func.bind.apply(func, [null].concat(slice(arguments, 1)));
      }

      var nextTick = setTimeout;

      var noop = function noop() { };

      function raf(func) {
        return requestAnimationFrame(func);
      }

      function typeOf(type, subject) {
        return typeof subject === type;
      }

      function isObject(subject) {
        return !isNull(subject) && typeOf("object", subject);
      }

      var isArray = Array.isArray;
      var isFunction = apply(typeOf, "function");
      var isString = apply(typeOf, "string");
      var isUndefined = apply(typeOf, "undefined");

      function isNull(subject) {
        return subject === null;
      }

      function isHTMLElement(subject) {
        try {
          return subject instanceof (subject.ownerDocument.defaultView || window).HTMLElement;
        } catch (e) {
          return false;
        }
      }

      function toArray(value) {
        return isArray(value) ? value : [value];
      }

      function forEach(values, iteratee) {
        toArray(values).forEach(iteratee);
      }

      function includes(array, value) {
        return array.indexOf(value) > -1;
      }

      function push(array, items) {
        array.push.apply(array, toArray(items));
        return array;
      }

      function toggleClass(elm, classes, add) {
        if (elm) {
          forEach(classes, function (name) {
            if (name) {
              elm.classList[add ? "add" : "remove"](name);
            }
          });
        }
      }

      function addClass(elm, classes) {
        toggleClass(elm, isString(classes) ? classes.split(" ") : classes, true);
      }

      function append(parent, children) {
        forEach(children, parent.appendChild.bind(parent));
      }

      function before(nodes, ref) {
        forEach(nodes, function (node) {
          var parent = (ref || node).parentNode;

          if (parent) {
            parent.insertBefore(node, ref);
          }
        });
      }

      function matches(elm, selector) {
        return isHTMLElement(elm) && (elm["msMatchesSelector"] || elm.matches).call(elm, selector);
      }

      function children(parent, selector) {
        var children2 = parent ? slice(parent.children) : [];
        return selector ? children2.filter(function (child) {
          return matches(child, selector);
        }) : children2;
      }

      function child(parent, selector) {
        return selector ? children(parent, selector)[0] : parent.firstElementChild;
      }

      var ownKeys = Object.keys;

      function forOwn(object, iteratee, right) {
        if (object) {
          (right ? ownKeys(object).reverse() : ownKeys(object)).forEach(function (key) {
            key !== "__proto__" && iteratee(object[key], key);
          });
        }

        return object;
      }

      function assign(object) {
        slice(arguments, 1).forEach(function (source) {
          forOwn(source, function (value, key) {
            object[key] = source[key];
          });
        });
        return object;
      }

      function merge(object) {
        slice(arguments, 1).forEach(function (source) {
          forOwn(source, function (value, key) {
            if (isArray(value)) {
              object[key] = value.slice();
            } else if (isObject(value)) {
              object[key] = merge({}, isObject(object[key]) ? object[key] : {}, value);
            } else {
              object[key] = value;
            }
          });
        });
        return object;
      }

      function omit(object, keys) {
        forEach(keys || ownKeys(object), function (key) {
          delete object[key];
        });
      }

      function removeAttribute(elms, attrs) {
        forEach(elms, function (elm) {
          forEach(attrs, function (attr) {
            elm && elm.removeAttribute(attr);
          });
        });
      }

      function setAttribute(elms, attrs, value) {
        if (isObject(attrs)) {
          forOwn(attrs, function (value2, name) {
            setAttribute(elms, name, value2);
          });
        } else {
          forEach(elms, function (elm) {
            isNull(value) || value === "" ? removeAttribute(elm, attrs) : elm.setAttribute(attrs, String(value));
          });
        }
      }

      function create(tag, attrs, parent) {
        var elm = document.createElement(tag);

        if (attrs) {
          isString(attrs) ? addClass(elm, attrs) : setAttribute(elm, attrs);
        }

        parent && append(parent, elm);
        return elm;
      }

      function style(elm, prop, value) {
        if (isUndefined(value)) {
          return getComputedStyle(elm)[prop];
        }

        if (!isNull(value)) {
          elm.style[prop] = "" + value;
        }
      }

      function display(elm, display2) {
        style(elm, "display", display2);
      }

      function focus(elm) {
        elm["setActive"] && elm["setActive"]() || elm.focus({
          preventScroll: true
        });
      }

      function getAttribute(elm, attr) {
        return elm.getAttribute(attr);
      }

      function hasClass(elm, className) {
        return elm && elm.classList.contains(className);
      }

      function rect(target) {
        return target.getBoundingClientRect();
      }

      function remove(nodes) {
        forEach(nodes, function (node) {
          if (node && node.parentNode) {
            node.parentNode.removeChild(node);
          }
        });
      }

      function parseHtml(html) {
        return child(new DOMParser().parseFromString(html, "text/html").body);
      }

      function prevent(e, stopPropagation) {
        e.preventDefault();

        if (stopPropagation) {
          e.stopPropagation();
          e.stopImmediatePropagation();
        }
      }

      function query(parent, selector) {
        return parent && parent.querySelector(selector);
      }

      function queryAll(parent, selector) {
        return selector ? slice(parent.querySelectorAll(selector)) : [];
      }

      function removeClass(elm, classes) {
        toggleClass(elm, classes, false);
      }

      function timeOf(e) {
        return e.timeStamp;
      }

      function unit(value) {
        return isString(value) ? value : value ? value + "px" : "";
      }

      var PROJECT_CODE = "splide";
      var DATA_ATTRIBUTE = "data-" + PROJECT_CODE;

      function assert(condition, message) {
        if (!condition) {
          throw new Error("[" + PROJECT_CODE + "] " + (message || ""));
        }
      }

      var min = Math.min,
        max = Math.max,
        floor = Math.floor,
        ceil = Math.ceil,
        abs = Math.abs;

      function approximatelyEqual(x, y, epsilon) {
        return abs(x - y) < epsilon;
      }

      function between(number, x, y, exclusive) {
        var minimum = min(x, y);
        var maximum = max(x, y);
        return exclusive ? minimum < number && number < maximum : minimum <= number && number <= maximum;
      }

      function clamp(number, x, y) {
        var minimum = min(x, y);
        var maximum = max(x, y);
        return min(max(minimum, number), maximum);
      }

      function sign(x) {
        return +(x > 0) - +(x < 0);
      }

      function format(string, replacements) {
        forEach(replacements, function (replacement) {
          string = string.replace("%s", "" + replacement);
        });
        return string;
      }

      function pad(number) {
        return number < 10 ? "0" + number : "" + number;
      }

      var ids = {};

      function uniqueId(prefix) {
        return "" + prefix + pad(ids[prefix] = (ids[prefix] || 0) + 1);
      }

      function EventBinder() {
        var listeners = [];

        function bind(targets, events, callback, options) {
          forEachEvent(targets, events, function (target, event, namespace) {
            var isEventTarget = ("addEventListener" in target);
            var remover = isEventTarget ? target.removeEventListener.bind(target, event, callback, options) : target["removeListener"].bind(target, callback);
            isEventTarget ? target.addEventListener(event, callback, options) : target["addListener"](callback);
            listeners.push([target, event, namespace, callback, remover]);
          });
        }

        function unbind(targets, events, callback) {
          forEachEvent(targets, events, function (target, event, namespace) {
            listeners = listeners.filter(function (listener) {
              if (listener[0] === target && listener[1] === event && listener[2] === namespace && (!callback || listener[3] === callback)) {
                listener[4]();
                return false;
              }

              return true;
            });
          });
        }

        function dispatch(target, type, detail) {
          var e;
          var bubbles = true;

          if (typeof CustomEvent === "function") {
            e = new CustomEvent(type, {
              bubbles: bubbles,
              detail: detail
            });
          } else {
            e = document.createEvent("CustomEvent");
            e.initCustomEvent(type, bubbles, false, detail);
          }

          target.dispatchEvent(e);
          return e;
        }

        function forEachEvent(targets, events, iteratee) {
          forEach(targets, function (target) {
            target && forEach(events, function (events2) {
              events2.split(" ").forEach(function (eventNS) {
                var fragment = eventNS.split(".");
                iteratee(target, fragment[0], fragment[1]);
              });
            });
          });
        }

        function destroy() {
          listeners.forEach(function (data) {
            data[4]();
          });
          empty(listeners);
        }

        return {
          bind: bind,
          unbind: unbind,
          dispatch: dispatch,
          destroy: destroy
        };
      }

      var EVENT_MOUNTED = "mounted";
      var EVENT_READY = "ready";
      var EVENT_MOVE = "move";
      var EVENT_MOVED = "moved";
      var EVENT_CLICK = "click";
      var EVENT_ACTIVE = "active";
      var EVENT_INACTIVE = "inactive";
      var EVENT_VISIBLE = "visible";
      var EVENT_HIDDEN = "hidden";
      var EVENT_REFRESH = "refresh";
      var EVENT_UPDATED = "updated";
      var EVENT_RESIZE = "resize";
      var EVENT_RESIZED = "resized";
      var EVENT_DRAG = "drag";
      var EVENT_DRAGGING = "dragging";
      var EVENT_DRAGGED = "dragged";
      var EVENT_SCROLL = "scroll";
      var EVENT_SCROLLED = "scrolled";
      var EVENT_OVERFLOW = "overflow";
      var EVENT_DESTROY = "destroy";
      var EVENT_ARROWS_MOUNTED = "arrows:mounted";
      var EVENT_ARROWS_UPDATED = "arrows:updated";
      var EVENT_PAGINATION_MOUNTED = "pagination:mounted";
      var EVENT_PAGINATION_UPDATED = "pagination:updated";
      var EVENT_NAVIGATION_MOUNTED = "navigation:mounted";
      var EVENT_AUTOPLAY_PLAY = "autoplay:play";
      var EVENT_AUTOPLAY_PLAYING = "autoplay:playing";
      var EVENT_AUTOPLAY_PAUSE = "autoplay:pause";
      var EVENT_LAZYLOAD_LOADED = "lazyload:loaded";
      var EVENT_SLIDE_KEYDOWN = "sk";
      var EVENT_SHIFTED = "sh";
      var EVENT_END_INDEX_CHANGED = "ei";

      function EventInterface(Splide2) {
        var bus = Splide2 ? Splide2.event.bus : document.createDocumentFragment();
        var binder = EventBinder();

        function on(events, callback) {
          binder.bind(bus, toArray(events).join(" "), function (e) {
            callback.apply(callback, isArray(e.detail) ? e.detail : []);
          });
        }

        function emit(event) {
          binder.dispatch(bus, event, slice(arguments, 1));
        }

        if (Splide2) {
          Splide2.event.on(EVENT_DESTROY, binder.destroy);
        }

        return assign(binder, {
          bus: bus,
          on: on,
          off: apply(binder.unbind, bus),
          emit: emit
        });
      }

      function RequestInterval(interval, onInterval, onUpdate, limit) {
        var now = Date.now;
        var startTime;
        var rate = 0;
        var id;
        var paused = true;
        var count = 0;

        function update() {
          if (!paused) {
            rate = interval ? min((now() - startTime) / interval, 1) : 1;
            onUpdate && onUpdate(rate);

            if (rate >= 1) {
              onInterval();
              startTime = now();

              if (limit && ++count >= limit) {
                return pause();
              }
            }

            id = raf(update);
          }
        }

        function start(resume) {
          resume || cancel();
          startTime = now() - (resume ? rate * interval : 0);
          paused = false;
          id = raf(update);
        }

        function pause() {
          paused = true;
        }

        function rewind() {
          startTime = now();
          rate = 0;

          if (onUpdate) {
            onUpdate(rate);
          }
        }

        function cancel() {
          id && cancelAnimationFrame(id);
          rate = 0;
          id = 0;
          paused = true;
        }

        function set(time) {
          interval = time;
        }

        function isPaused() {
          return paused;
        }

        return {
          start: start,
          rewind: rewind,
          pause: pause,
          cancel: cancel,
          set: set,
          isPaused: isPaused
        };
      }

      function State(initialState) {
        var state = initialState;

        function set(value) {
          state = value;
        }

        function is(states) {
          return includes(toArray(states), state);
        }

        return {
          set: set,
          is: is
        };
      }

      function Throttle(func, duration) {
        var interval = RequestInterval(duration || 0, func, null, 1);
        return function () {
          interval.isPaused() && interval.start();
        };
      }

      function Media(Splide2, Components2, options) {
        var state = Splide2.state;
        var breakpoints = options.breakpoints || {};
        var reducedMotion = options.reducedMotion || {};
        var binder = EventBinder();
        var queries = [];

        function setup() {
          var isMin = options.mediaQuery === "min";
          ownKeys(breakpoints).sort(function (n, m) {
            return isMin ? +n - +m : +m - +n;
          }).forEach(function (key) {
            register(breakpoints[key], "(" + (isMin ? "min" : "max") + "-width:" + key + "px)");
          });
          register(reducedMotion, MEDIA_PREFERS_REDUCED_MOTION);
          update();
        }

        function destroy(completely) {
          if (completely) {
            binder.destroy();
          }
        }

        function register(options2, query) {
          var queryList = matchMedia(query);
          binder.bind(queryList, "change", update);
          queries.push([options2, queryList]);
        }

        function update() {
          var destroyed = state.is(DESTROYED);
          var direction = options.direction;
          var merged = queries.reduce(function (merged2, entry) {
            return merge(merged2, entry[1].matches ? entry[0] : {});
          }, {});
          omit(options);
          set(merged);

          if (options.destroy) {
            Splide2.destroy(options.destroy === "completely");
          } else if (destroyed) {
            destroy(true);
            Splide2.mount();
          } else {
            direction !== options.direction && Splide2.refresh();
          }
        }

        function reduce(enable) {
          if (matchMedia(MEDIA_PREFERS_REDUCED_MOTION).matches) {
            enable ? merge(options, reducedMotion) : omit(options, ownKeys(reducedMotion));
          }
        }

        function set(opts, base, notify) {
          merge(options, opts);
          base && merge(Object.getPrototypeOf(options), opts);

          if (notify || !state.is(CREATED)) {
            Splide2.emit(EVENT_UPDATED, options);
          }
        }

        return {
          setup: setup,
          destroy: destroy,
          reduce: reduce,
          set: set
        };
      }

      var ARROW = "Arrow";
      var ARROW_LEFT = ARROW + "Left";
      var ARROW_RIGHT = ARROW + "Right";
      var ARROW_UP = ARROW + "Up";
      var ARROW_DOWN = ARROW + "Down";
      var RTL = "rtl";
      var TTB = "ttb";
      var ORIENTATION_MAP = {
        width: ["height"],
        left: ["top", "right"],
        right: ["bottom", "left"],
        x: ["y"],
        X: ["Y"],
        Y: ["X"],
        ArrowLeft: [ARROW_UP, ARROW_RIGHT],
        ArrowRight: [ARROW_DOWN, ARROW_LEFT]
      };

      function Direction(Splide2, Components2, options) {
        function resolve(prop, axisOnly, direction) {
          direction = direction || options.direction;
          var index = direction === RTL && !axisOnly ? 1 : direction === TTB ? 0 : -1;
          return ORIENTATION_MAP[prop] && ORIENTATION_MAP[prop][index] || prop.replace(/width|left|right/i, function (match, offset) {
            var replacement = ORIENTATION_MAP[match.toLowerCase()][index] || match;
            return offset > 0 ? replacement.charAt(0).toUpperCase() + replacement.slice(1) : replacement;
          });
        }

        function orient(value) {
          return value * (options.direction === RTL ? 1 : -1);
        }

        return {
          resolve: resolve,
          orient: orient
        };
      }

      var ROLE = "role";
      var TAB_INDEX = "tabindex";
      var DISABLED = "disabled";
      var ARIA_PREFIX = "aria-";
      var ARIA_CONTROLS = ARIA_PREFIX + "controls";
      var ARIA_CURRENT = ARIA_PREFIX + "current";
      var ARIA_SELECTED = ARIA_PREFIX + "selected";
      var ARIA_LABEL = ARIA_PREFIX + "label";
      var ARIA_LABELLEDBY = ARIA_PREFIX + "labelledby";
      var ARIA_HIDDEN = ARIA_PREFIX + "hidden";
      var ARIA_ORIENTATION = ARIA_PREFIX + "orientation";
      var ARIA_ROLEDESCRIPTION = ARIA_PREFIX + "roledescription";
      var ARIA_LIVE = ARIA_PREFIX + "live";
      var ARIA_BUSY = ARIA_PREFIX + "busy";
      var ARIA_ATOMIC = ARIA_PREFIX + "atomic";
      var ALL_ATTRIBUTES = [ROLE, TAB_INDEX, DISABLED, ARIA_CONTROLS, ARIA_CURRENT, ARIA_LABEL, ARIA_LABELLEDBY, ARIA_HIDDEN, ARIA_ORIENTATION, ARIA_ROLEDESCRIPTION];
      var CLASS_PREFIX = PROJECT_CODE + "__";
      var STATUS_CLASS_PREFIX = "is-";
      var CLASS_ROOT = PROJECT_CODE;
      var CLASS_TRACK = CLASS_PREFIX + "track";
      var CLASS_LIST = CLASS_PREFIX + "list";
      var CLASS_SLIDE = CLASS_PREFIX + "slide";
      var CLASS_CLONE = CLASS_SLIDE + "--clone";
      var CLASS_CONTAINER = CLASS_SLIDE + "__container";
      var CLASS_ARROWS = CLASS_PREFIX + "arrows";
      var CLASS_ARROW = CLASS_PREFIX + "arrow";
      var CLASS_ARROW_PREV = CLASS_ARROW + "--prev";
      var CLASS_ARROW_NEXT = CLASS_ARROW + "--next";
      var CLASS_PAGINATION = CLASS_PREFIX + "pagination";
      var CLASS_PAGINATION_PAGE = CLASS_PAGINATION + "__page";
      var CLASS_PROGRESS = CLASS_PREFIX + "progress";
      var CLASS_PROGRESS_BAR = CLASS_PROGRESS + "__bar";
      var CLASS_TOGGLE = CLASS_PREFIX + "toggle";
      var CLASS_SPINNER = CLASS_PREFIX + "spinner";
      var CLASS_SR = CLASS_PREFIX + "sr";
      var CLASS_INITIALIZED = STATUS_CLASS_PREFIX + "initialized";
      var CLASS_ACTIVE = STATUS_CLASS_PREFIX + "active";
      var CLASS_PREV = STATUS_CLASS_PREFIX + "prev";
      var CLASS_NEXT = STATUS_CLASS_PREFIX + "next";
      var CLASS_VISIBLE = STATUS_CLASS_PREFIX + "visible";
      var CLASS_LOADING = STATUS_CLASS_PREFIX + "loading";
      var CLASS_FOCUS_IN = STATUS_CLASS_PREFIX + "focus-in";
      var CLASS_OVERFLOW = STATUS_CLASS_PREFIX + "overflow";
      var STATUS_CLASSES = [CLASS_ACTIVE, CLASS_VISIBLE, CLASS_PREV, CLASS_NEXT, CLASS_LOADING, CLASS_FOCUS_IN, CLASS_OVERFLOW];
      var CLASSES = {
        slide: CLASS_SLIDE,
        clone: CLASS_CLONE,
        arrows: CLASS_ARROWS,
        arrow: CLASS_ARROW,
        prev: CLASS_ARROW_PREV,
        next: CLASS_ARROW_NEXT,
        pagination: CLASS_PAGINATION,
        page: CLASS_PAGINATION_PAGE,
        spinner: CLASS_SPINNER
      };

      function closest(from, selector) {
        if (isFunction(from.closest)) {
          return from.closest(selector);
        }

        var elm = from;

        while (elm && elm.nodeType === 1) {
          if (matches(elm, selector)) {
            break;
          }

          elm = elm.parentElement;
        }

        return elm;
      }

      var FRICTION = 5;
      var LOG_INTERVAL = 200;
      var POINTER_DOWN_EVENTS = "touchstart mousedown";
      var POINTER_MOVE_EVENTS = "touchmove mousemove";
      var POINTER_UP_EVENTS = "touchend touchcancel mouseup click";

      function Elements(Splide2, Components2, options) {
        var _EventInterface = EventInterface(Splide2),
          on = _EventInterface.on,
          bind = _EventInterface.bind;

        var root = Splide2.root;
        var i18n = options.i18n;
        var elements = {};
        var slides = [];
        var rootClasses = [];
        var trackClasses = [];
        var track;
        var list;
        var isUsingKey;

        function setup() {
          collect();
          init();
          update();
        }

        function mount() {
          on(EVENT_REFRESH, destroy);
          on(EVENT_REFRESH, setup);
          on(EVENT_UPDATED, update);
          bind(document, POINTER_DOWN_EVENTS + " keydown", function (e) {
            isUsingKey = e.type === "keydown";
          }, {
            capture: true
          });
          bind(root, "focusin", function () {
            toggleClass(root, CLASS_FOCUS_IN, !!isUsingKey);
          });
        }

        function destroy(completely) {
          var attrs = ALL_ATTRIBUTES.concat("style");
          empty(slides);
          removeClass(root, rootClasses);
          removeClass(track, trackClasses);
          removeAttribute([track, list], attrs);
          removeAttribute(root, completely ? attrs : ["style", ARIA_ROLEDESCRIPTION]);
        }

        function update() {
          removeClass(root, rootClasses);
          removeClass(track, trackClasses);
          rootClasses = getClasses(CLASS_ROOT);
          trackClasses = getClasses(CLASS_TRACK);
          addClass(root, rootClasses);
          addClass(track, trackClasses);
          setAttribute(root, ARIA_LABEL, options.label);
          setAttribute(root, ARIA_LABELLEDBY, options.labelledby);
        }

        function collect() {
          track = find("." + CLASS_TRACK);
          list = child(track, "." + CLASS_LIST);
          assert(track && list, "A track/list element is missing.");
          push(slides, children(list, "." + CLASS_SLIDE + ":not(." + CLASS_CLONE + ")"));
          forOwn({
            arrows: CLASS_ARROWS,
            pagination: CLASS_PAGINATION,
            prev: CLASS_ARROW_PREV,
            next: CLASS_ARROW_NEXT,
            bar: CLASS_PROGRESS_BAR,
            toggle: CLASS_TOGGLE
          }, function (className, key) {
            elements[key] = find("." + className);
          });
          assign(elements, {
            root: root,
            track: track,
            list: list,
            slides: slides
          });
        }

        function init() {
          var id = root.id || uniqueId(PROJECT_CODE);
          var role = options.role;
          root.id = id;
          track.id = track.id || id + "-track";
          list.id = list.id || id + "-list";

          if (!getAttribute(root, ROLE) && root.tagName !== "SECTION" && role) {
            setAttribute(root, ROLE, role);
          }

          setAttribute(root, ARIA_ROLEDESCRIPTION, i18n.carousel);
          setAttribute(list, ROLE, "presentation");
        }

        function find(selector) {
          var elm = query(root, selector);
          return elm && closest(elm, "." + CLASS_ROOT) === root ? elm : void 0;
        }

        function getClasses(base) {
          return [base + "--" + options.type, base + "--" + options.direction, options.drag && base + "--draggable", options.isNavigation && base + "--nav", base === CLASS_ROOT && CLASS_ACTIVE];
        }

        return assign(elements, {
          setup: setup,
          mount: mount,
          destroy: destroy
        });
      }

      var SLIDE = "slide";
      var LOOP = "loop";
      var FADE = "fade";

      function Slide$1(Splide2, index, slideIndex, slide) {
        var event = EventInterface(Splide2);
        var on = event.on,
          emit = event.emit,
          bind = event.bind;
        var Components = Splide2.Components,
          root = Splide2.root,
          options = Splide2.options;
        var isNavigation = options.isNavigation,
          updateOnMove = options.updateOnMove,
          i18n = options.i18n,
          pagination = options.pagination,
          slideFocus = options.slideFocus;
        var resolve = Components.Direction.resolve;
        var styles = getAttribute(slide, "style");
        var label = getAttribute(slide, ARIA_LABEL);
        var isClone = slideIndex > -1;
        var container = child(slide, "." + CLASS_CONTAINER);
        var destroyed;

        function mount() {
          if (!isClone) {
            slide.id = root.id + "-slide" + pad(index + 1);
            setAttribute(slide, ROLE, pagination ? "tabpanel" : "group");
            setAttribute(slide, ARIA_ROLEDESCRIPTION, i18n.slide);
            setAttribute(slide, ARIA_LABEL, label || format(i18n.slideLabel, [index + 1, Splide2.length]));
          }

          listen();
        }

        function listen() {
          bind(slide, "click", apply(emit, EVENT_CLICK, self));
          bind(slide, "keydown", apply(emit, EVENT_SLIDE_KEYDOWN, self));
          on([EVENT_MOVED, EVENT_SHIFTED, EVENT_SCROLLED], update);
          on(EVENT_NAVIGATION_MOUNTED, initNavigation);

          if (updateOnMove) {
            on(EVENT_MOVE, onMove);
          }
        }

        function destroy() {
          destroyed = true;
          event.destroy();
          removeClass(slide, STATUS_CLASSES);
          removeAttribute(slide, ALL_ATTRIBUTES);
          setAttribute(slide, "style", styles);
          setAttribute(slide, ARIA_LABEL, label || "");
        }

        function initNavigation() {
          var controls = Splide2.splides.map(function (target) {
            var Slide2 = target.splide.Components.Slides.getAt(index);
            return Slide2 ? Slide2.slide.id : "";
          }).join(" ");
          setAttribute(slide, ARIA_LABEL, format(i18n.slideX, (isClone ? slideIndex : index) + 1));
          setAttribute(slide, ARIA_CONTROLS, controls);
          setAttribute(slide, ROLE, slideFocus ? "button" : "");
          slideFocus && removeAttribute(slide, ARIA_ROLEDESCRIPTION);
        }

        function onMove() {
          if (!destroyed) {
            update();
          }
        }

        function update() {
          if (!destroyed) {
            var curr = Splide2.index;
            updateActivity();
            updateVisibility();
            toggleClass(slide, CLASS_PREV, index === curr - 1);
            toggleClass(slide, CLASS_NEXT, index === curr + 1);
            //   toggleClass(slide, 'left', index < curr);
            //   toggleClass(slide, 'right', index > curr);
          }
        }

        function updateActivity() {
          var active = isActive();

          if (active !== hasClass(slide, CLASS_ACTIVE)) {
            toggleClass(slide, CLASS_ACTIVE, active);
            setAttribute(slide, ARIA_CURRENT, isNavigation && active || "");
            emit(active ? EVENT_ACTIVE : EVENT_INACTIVE, self);
          }
        }

        function updateVisibility() {
          var visible = isVisible();
          var hidden = !visible && (!isActive() || isClone);

          if (!Splide2.state.is([MOVING, SCROLLING])) {
            setAttribute(slide, ARIA_HIDDEN, hidden || "");
          }

          setAttribute(queryAll(slide, options.focusableNodes || ""), TAB_INDEX, hidden ? -1 : "");

          if (slideFocus) {
            setAttribute(slide, TAB_INDEX, hidden ? -1 : 0);
          }

          if (visible !== hasClass(slide, CLASS_VISIBLE)) {
            toggleClass(slide, CLASS_VISIBLE, visible);
            emit(visible ? EVENT_VISIBLE : EVENT_HIDDEN, self);
          }

          if (!visible && document.activeElement === slide) {
            var Slide2 = Components.Slides.getAt(Splide2.index);
            Slide2 && focus(Slide2.slide);
          }
        }

        function style$1(prop, value, useContainer) {
          style(useContainer && container || slide, prop, value);
        }

        function isActive() {
          var curr = Splide2.index;
          return curr === index || options.cloneStatus && curr === slideIndex;
        }

        function isVisible() {
          if (Splide2.is(FADE)) {
            return isActive();
          }

          var trackRect = rect(Components.Elements.track);
          var slideRect = rect(slide);
          var left = resolve("left", true);
          var right = resolve("right", true);
          return floor(trackRect[left]) <= ceil(slideRect[left]) && floor(slideRect[right]) <= ceil(trackRect[right]);
        }

        function isWithin(from, distance) {
          var diff = abs(from - index);

          if (!isClone && (options.rewind || Splide2.is(LOOP))) {
            diff = min(diff, Splide2.length - diff);
          }

          return diff <= distance;
        }

        var self = {
          index: index,
          slideIndex: slideIndex,
          slide: slide,
          container: container,
          isClone: isClone,
          mount: mount,
          destroy: destroy,
          update: update,
          style: style$1,
          isWithin: isWithin
        };
        return self;
      }

      function Slides(Splide2, Components2, options) {
        var _EventInterface2 = EventInterface(Splide2),
          on = _EventInterface2.on,
          emit = _EventInterface2.emit,
          bind = _EventInterface2.bind;

        var _Components2$Elements = Components2.Elements,
          slides = _Components2$Elements.slides,
          list = _Components2$Elements.list;
        var Slides2 = [];

        function mount() {
          init();
          on(EVENT_REFRESH, destroy);
          on(EVENT_REFRESH, init);
        }

        function init() {
          slides.forEach(function (slide, index) {
            register(slide, index, -1);
          });
        }

        function destroy() {
          forEach$1(function (Slide2) {
            Slide2.destroy();
          });
          empty(Slides2);
        }

        function update() {
          forEach$1(function (Slide2) {
            Slide2.update();
          });
        }

        function register(slide, index, slideIndex) {
          var object = Slide$1(Splide2, index, slideIndex, slide);
          object.mount();
          Slides2.push(object);
          Slides2.sort(function (Slide1, Slide2) {
            return Slide1.index - Slide2.index;
          });
        }

        function get(excludeClones) {
          return excludeClones ? filter(function (Slide2) {
            return !Slide2.isClone;
          }) : Slides2;
        }

        function getIn(page) {
          var Controller = Components2.Controller;
          var index = Controller.toIndex(page);
          var max = Controller.hasFocus() ? 1 : options.perPage;
          return filter(function (Slide2) {
            return between(Slide2.index, index, index + max - 1);
          });
        }

        function getAt(index) {
          return filter(index)[0];
        }

        function add(items, index) {
          forEach(items, function (slide) {
            if (isString(slide)) {
              slide = parseHtml(slide);
            }

            if (isHTMLElement(slide)) {
              var ref = slides[index];
              ref ? before(slide, ref) : append(list, slide);
              addClass(slide, options.classes.slide);
              observeImages(slide, apply(emit, EVENT_RESIZE));
            }
          });
          emit(EVENT_REFRESH);
        }

        function remove$1(matcher) {
          remove(filter(matcher).map(function (Slide2) {
            return Slide2.slide;
          }));
          emit(EVENT_REFRESH);
        }

        function forEach$1(iteratee, excludeClones) {
          get(excludeClones).forEach(iteratee);
        }

        function filter(matcher) {
          return Slides2.filter(isFunction(matcher) ? matcher : function (Slide2) {
            return isString(matcher) ? matches(Slide2.slide, matcher) : includes(toArray(matcher), Slide2.index);
          });
        }

        function style(prop, value, useContainer) {
          forEach$1(function (Slide2) {
            Slide2.style(prop, value, useContainer);
          });
        }

        function observeImages(elm, callback) {
          var images = queryAll(elm, "img");
          var length = images.length;

          if (length) {
            images.forEach(function (img) {
              bind(img, "load error", function () {
                if (! --length) {
                  callback();
                }
              });
            });
          } else {
            callback();
          }
        }

        function getLength(excludeClones) {
          return excludeClones ? slides.length : Slides2.length;
        }

        function isEnough() {
          return Slides2.length > options.perPage;
        }

        return {
          mount: mount,
          destroy: destroy,
          update: update,
          register: register,
          get: get,
          getIn: getIn,
          getAt: getAt,
          add: add,
          remove: remove$1,
          forEach: forEach$1,
          filter: filter,
          style: style,
          getLength: getLength,
          isEnough: isEnough
        };
      }

      function Layout(Splide2, Components2, options) {
        var _EventInterface3 = EventInterface(Splide2),
          on = _EventInterface3.on,
          bind = _EventInterface3.bind,
          emit = _EventInterface3.emit;

        var Slides = Components2.Slides;
        var resolve = Components2.Direction.resolve;
        var _Components2$Elements2 = Components2.Elements,
          root = _Components2$Elements2.root,
          track = _Components2$Elements2.track,
          list = _Components2$Elements2.list;
        var getAt = Slides.getAt,
          styleSlides = Slides.style;
        var vertical;
        var rootRect;
        var overflow;

        function mount() {
          init();
          bind(window, "resize load", Throttle(apply(emit, EVENT_RESIZE)));
          on([EVENT_UPDATED, EVENT_REFRESH], init);
          on(EVENT_RESIZE, resize);
        }

        function init() {
          vertical = options.direction === TTB;
          style(root, "maxWidth", unit(options.width));
          style(track, resolve("paddingLeft"), cssPadding(false));
          style(track, resolve("paddingRight"), cssPadding(true));
          resize(true);
        }

        function resize(force) {
          var newRect = rect(root);

          if (force || rootRect.width !== newRect.width || rootRect.height !== newRect.height) {
            style(track, "height", cssTrackHeight());
            styleSlides(resolve("marginRight"), unit(options.gap));
            styleSlides("width", cssSlideWidth());
            styleSlides("height", cssSlideHeight(), true);
            rootRect = newRect;
            emit(EVENT_RESIZED);

            if (overflow !== (overflow = isOverflow())) {
              toggleClass(root, CLASS_OVERFLOW, overflow);
              emit(EVENT_OVERFLOW, overflow);
            }
          }
        }

        function cssPadding(right) {
          var padding = options.padding;
          var prop = resolve(right ? "right" : "left");
          return padding && unit(padding[prop] || (isObject(padding) ? 0 : padding)) || "0px";
        }

        function cssTrackHeight() {
          var height = "";

          if (vertical) {
            height = cssHeight();
            assert(height, "height or heightRatio is missing.");
            height = "calc(" + height + " - " + cssPadding(false) + " - " + cssPadding(true) + ")";
          }

          return height;
        }

        function cssHeight() {
          return unit(options.height || rect(list).width * options.heightRatio);
        }

        function cssSlideWidth() {
          return options.autoWidth ? null : unit(options.fixedWidth) || (vertical ? "" : cssSlideSize());
        }

        function cssSlideHeight() {
          return unit(options.fixedHeight) || (vertical ? options.autoHeight ? null : cssSlideSize() : cssHeight());
        }

        function cssSlideSize() {
          var gap = unit(options.gap);
          return "calc((100%" + (gap && " + " + gap) + ")/" + (options.perPage || 1) + (gap && " - " + gap) + ")";
        }

        function listSize() {
          return rect(list)[resolve("width")];
        }

        function slideSize(index, withoutGap) {
          var Slide = getAt(index || 0);
          return Slide ? rect(Slide.slide)[resolve("width")] + (withoutGap ? 0 : getGap()) : 0;
        }

        function totalSize(index, withoutGap) {
          var Slide = getAt(index);

          if (Slide) {
            var right = rect(Slide.slide)[resolve("right")];
            var left = rect(list)[resolve("left")];
            return abs(right - left) + (withoutGap ? 0 : getGap());
          }

          return 0;
        }

        function sliderSize(withoutGap) {
          return totalSize(Splide2.length - 1) - totalSize(0) + slideSize(0, withoutGap);
        }

        function getGap() {
          var Slide = getAt(0);
          return Slide && parseFloat(style(Slide.slide, resolve("marginRight"))) || 0;
        }

        function getPadding(right) {
          return parseFloat(style(track, resolve("padding" + (right ? "Right" : "Left")))) || 0;
        }

        function isOverflow() {
          return Splide2.is(FADE) || sliderSize(true) > listSize();
        }

        return {
          mount: mount,
          resize: resize,
          listSize: listSize,
          slideSize: slideSize,
          sliderSize: sliderSize,
          totalSize: totalSize,
          getPadding: getPadding,
          isOverflow: isOverflow
        };
      }

      var MULTIPLIER = 2;

      function Clones(Splide2, Components2, options) {
        var event = EventInterface(Splide2);
        var on = event.on;
        var Elements = Components2.Elements,
          Slides = Components2.Slides;
        var resolve = Components2.Direction.resolve;
        var clones = [];
        var cloneCount;

        function mount() {
          on(EVENT_REFRESH, remount);
          on([EVENT_UPDATED, EVENT_RESIZE], observe);

          if (cloneCount = computeCloneCount()) {
            generate(cloneCount);
            Components2.Layout.resize(true);
          }
        }

        function remount() {
          destroy();
          mount();
        }

        function destroy() {
          remove(clones);
          empty(clones);
          event.destroy();
        }

        function observe() {
          var count = computeCloneCount();

          if (cloneCount !== count) {
            if (cloneCount < count || !count) {
              event.emit(EVENT_REFRESH);
            }
          }
        }

        function generate(count) {
          var slides = Slides.get().slice();
          var length = slides.length;

          if (length) {
            while (slides.length < count) {
              push(slides, slides);
            }

            push(slides.slice(-count), slides.slice(0, count)).forEach(function (Slide, index) {
              var isHead = index < count;
              var clone = cloneDeep(Slide.slide, index);
              isHead ? before(clone, slides[0].slide) : append(Elements.list, clone);
              push(clones, clone);
              Slides.register(clone, index - count + (isHead ? 0 : length), Slide.index);
            });
          }
        }

        function cloneDeep(elm, index) {
          var clone = elm.cloneNode(true);
          addClass(clone, options.classes.clone);
          clone.id = Splide2.root.id + "-clone" + pad(index + 1);
          return clone;
        }

        function computeCloneCount() {
          var clones2 = options.clones;

          if (!Splide2.is(LOOP)) {
            clones2 = 0;
          } else if (isUndefined(clones2)) {
            var fixedSize = options[resolve("fixedWidth")] && Components2.Layout.slideSize(0);
            var fixedCount = fixedSize && ceil(rect(Elements.track)[resolve("width")] / fixedSize);
            clones2 = fixedCount || options[resolve("autoWidth")] && Splide2.length || options.perPage * MULTIPLIER;
          }

          return clones2;
        }

        return {
          mount: mount,
          destroy: destroy
        };
      }

      function Move(Splide2, Components2, options) {
        var _EventInterface4 = EventInterface(Splide2),
          on = _EventInterface4.on,
          emit = _EventInterface4.emit;

        var set = Splide2.state.set;
        var _Components2$Layout = Components2.Layout,
          slideSize = _Components2$Layout.slideSize,
          getPadding = _Components2$Layout.getPadding,
          totalSize = _Components2$Layout.totalSize,
          listSize = _Components2$Layout.listSize,
          sliderSize = _Components2$Layout.sliderSize;
        var _Components2$Directio = Components2.Direction,
          resolve = _Components2$Directio.resolve,
          orient = _Components2$Directio.orient;
        var _Components2$Elements3 = Components2.Elements,
          list = _Components2$Elements3.list,
          track = _Components2$Elements3.track;
        var Transition;

        function mount() {
          Transition = Components2.Transition;
          on([EVENT_MOUNTED, EVENT_RESIZED, EVENT_UPDATED, EVENT_REFRESH], reposition);
        }

        function reposition() {
          if (!Components2.Controller.isBusy()) {
            Components2.Scroll.cancel();
            jump(Splide2.index);
            Components2.Slides.update();
          }
        }

        function move(dest, index, prev, callback) {
          if (dest !== index && canShift(dest > prev)) {
            cancel();
            translate(shift(getPosition(), dest > prev), true);
          }

          set(MOVING);

          emit(EVENT_MOVE, index, prev, dest);
          Transition.start(index, function () {
            set(IDLE);
            emit(EVENT_MOVED, index, prev, dest);
            callback && callback();
          });
        }

        function jump(index) {
          translate(toPosition(index, true));

        }

        function translate(position, preventLoop) {
          if (!Splide2.is(FADE)) {
            var destination = preventLoop ? position : loop(position);
            style(list, "transform", "translate" + resolve("X") + "(" + destination + "px)");
            position !== destination && emit(EVENT_SHIFTED);
          }
        }

        function loop(position) {
          if (Splide2.is(LOOP)) {
            var index = toIndex(position);
            var exceededMax = index > Components2.Controller.getEnd();
            var exceededMin = index < 0;

            if (exceededMin || exceededMax) {
              position = shift(position, exceededMax);
            }
          }

          return position;
        }

        function shift(position, backwards) {
          var excess = position - getLimit(backwards);
          var size = sliderSize();
          position -= orient(size * (ceil(abs(excess) / size) || 1)) * (backwards ? 1 : -1);
          return position;
        }

        function cancel() {
          translate(getPosition(), true);
          Transition.cancel();
        }

        function toIndex(position) {
          var Slides = Components2.Slides.get();
          var index = 0;
          var minDistance = Infinity;

          for (var i = 0; i < Slides.length; i++) {
            var slideIndex = Slides[i].index;
            var distance = abs(toPosition(slideIndex, true) - position);

            if (distance <= minDistance) {
              minDistance = distance;
              index = slideIndex;
            } else {
              break;
            }
          }

          return index;
        }

        function toPosition(index, trimming) {
          var position = orient(totalSize(index - 1) - offset(index));
          return trimming ? trim(position) : position;
        }

        function getPosition() {
          var left = resolve("left");
          return rect(list)[left] - rect(track)[left] + orient(getPadding(false));
        }

        function trim(position) {
          if (options.trimSpace && Splide2.is(SLIDE)) {
            position = clamp(position, 0, orient(sliderSize(true) - listSize()));
          }

          return position;
        }

        function offset(index) {
          var focus = options.focus;
          return focus === "center" ? (listSize() - slideSize(index, true)) / 2 : +focus * slideSize(index) || 0;
        }

        function getLimit(max) {
          return toPosition(max ? Components2.Controller.getEnd() : 0, !!options.trimSpace);
        }

        function canShift(backwards) {
          var shifted = orient(shift(getPosition(), backwards));
          return backwards ? shifted >= 0 : shifted <= list[resolve("scrollWidth")] - rect(track)[resolve("width")];
        }

        function exceededLimit(max, position) {
          position = isUndefined(position) ? getPosition() : position;
          var exceededMin = max !== true && orient(position) < orient(getLimit(false));
          var exceededMax = max !== false && orient(position) > orient(getLimit(true));
          return exceededMin || exceededMax;
        }

        return {
          mount: mount,
          move: move,
          jump: jump,
          translate: translate,
          shift: shift,
          cancel: cancel,
          toIndex: toIndex,
          toPosition: toPosition,
          getPosition: getPosition,
          getLimit: getLimit,
          exceededLimit: exceededLimit,
          reposition: reposition
        };
      }

      function Controller(Splide2, Components2, options) {
        var _EventInterface5 = EventInterface(Splide2),
          on = _EventInterface5.on,
          emit = _EventInterface5.emit;

        var Move = Components2.Move;
        var getPosition = Move.getPosition,
          getLimit = Move.getLimit,
          toPosition = Move.toPosition;
        var _Components2$Slides = Components2.Slides,
          isEnough = _Components2$Slides.isEnough,
          getLength = _Components2$Slides.getLength;
        var omitEnd = options.omitEnd;
        var isLoop = Splide2.is(LOOP);
        var isSlide = Splide2.is(SLIDE);
        var getNext = apply(getAdjacent, false);
        var getPrev = apply(getAdjacent, true);
        var currIndex = options.start || 0;
        var endIndex;
        var prevIndex = currIndex;
        var slideCount;
        var perMove;
        var perPage;

        function mount() {
          init();
          on([EVENT_UPDATED, EVENT_REFRESH, EVENT_END_INDEX_CHANGED], init);
          on(EVENT_RESIZED, onResized);
        }

        function init() {
          slideCount = getLength(true);
          perMove = options.perMove;
          perPage = options.perPage;
          endIndex = getEnd();
          var index = clamp(currIndex, 0, omitEnd ? endIndex : slideCount - 1);

          if (index !== currIndex) {
            currIndex = index;
            Move.reposition();
          }
        }

        function onResized() {
          if (endIndex !== getEnd()) {
            emit(EVENT_END_INDEX_CHANGED);
          }
        }

        function go(control, allowSameIndex, callback) {
          if (!isBusy()) {
            var dest = parse(control);
            var index = loop(dest);

            if (index > -1 && (allowSameIndex || index !== currIndex)) {
              setIndex(index);
              Move.move(dest, index, prevIndex, callback);
            }
          }
        }

        function scroll(destination, duration, snap, callback) {
          Components2.Scroll.scroll(destination, duration, snap, function () {
            var index = loop(Move.toIndex(getPosition()));
            setIndex(omitEnd ? min(index, endIndex) : index);
            callback && callback();
          });
        }

        function parse(control) {
          var index = currIndex;

          if (isString(control)) {
            var _ref = control.match(/([+\-<>])(\d+)?/) || [],
              indicator = _ref[1],
              number = _ref[2];

            if (indicator === "+" || indicator === "-") {
              index = computeDestIndex(currIndex + +("" + indicator + (+number || 1)), currIndex);
            } else if (indicator === ">") {
              index = number ? toIndex(+number) : getNext(true);
            } else if (indicator === "<") {
              index = getPrev(true);
            }
          } else {
            index = isLoop ? control : clamp(control, 0, endIndex);
          }

          return index;
        }

        function getAdjacent(prev, destination) {
          var number = perMove || (hasFocus() ? 1 : perPage);
          var dest = computeDestIndex(currIndex + number * (prev ? -1 : 1), currIndex, !(perMove || hasFocus()));

          if (dest === -1 && isSlide) {
            if (!approximatelyEqual(getPosition(), getLimit(!prev), 1)) {
              return prev ? 0 : endIndex;
            }
          }

          return destination ? dest : loop(dest);
        }

        function computeDestIndex(dest, from, snapPage) {
          if (isEnough() || hasFocus()) {
            var index = computeMovableDestIndex(dest);

            if (index !== dest) {
              from = dest;
              dest = index;
              snapPage = false;
            }

            if (dest < 0 || dest > endIndex) {
              if (!perMove && (between(0, dest, from, true) || between(endIndex, from, dest, true))) {
                dest = toIndex(toPage(dest));
              } else {
                if (isLoop) {
                  dest = snapPage ? dest < 0 ? -(slideCount % perPage || perPage) : slideCount : dest;
                } else if (options.rewind) {
                  dest = dest < 0 ? endIndex : 0;
                } else {
                  dest = -1;
                }
              }
            } else {
              if (snapPage && dest !== from) {
                dest = toIndex(toPage(from) + (dest < from ? -1 : 1));
              }
            }
          } else {
            dest = -1;
          }

          return dest;
        }

        function computeMovableDestIndex(dest) {
          if (isSlide && options.trimSpace === "move" && dest !== currIndex) {
            var position = getPosition();

            while (position === toPosition(dest, true) && between(dest, 0, Splide2.length - 1, !options.rewind)) {
              dest < currIndex ? --dest : ++dest;
            }
          }

          return dest;
        }

        function loop(index) {
          return isLoop ? (index + slideCount) % slideCount || 0 : index;
        }

        function getEnd() {
          var end = slideCount - (hasFocus() || isLoop && perMove ? 1 : perPage);

          while (omitEnd && end-- > 0) {
            if (toPosition(slideCount - 1, true) !== toPosition(end, true)) {
              end++;
              break;
            }
          }

          return clamp(end, 0, slideCount - 1);
        }

        function toIndex(page) {
          return clamp(hasFocus() ? page : perPage * page, 0, endIndex);
        }

        function toPage(index) {
          return hasFocus() ? min(index, endIndex) : floor((index >= endIndex ? slideCount - 1 : index) / perPage);
        }

        function toDest(destination) {
          var closest = Move.toIndex(destination);
          return isSlide ? clamp(closest, 0, endIndex) : closest;
        }

        function setIndex(index) {
          if (index !== currIndex) {
            prevIndex = currIndex;
            currIndex = index;
          }
        }

        function getIndex(prev) {
          return prev ? prevIndex : currIndex;
        }

        function hasFocus() {
          return !isUndefined(options.focus) || options.isNavigation;
        }

        function isBusy() {
          return Splide2.state.is([MOVING, SCROLLING]) && !!options.waitForTransition;
        }

        return {
          mount: mount,
          go: go,
          scroll: scroll,
          getNext: getNext,
          getPrev: getPrev,
          getAdjacent: getAdjacent,
          getEnd: getEnd,
          setIndex: setIndex,
          getIndex: getIndex,
          toIndex: toIndex,
          toPage: toPage,
          toDest: toDest,
          hasFocus: hasFocus,
          isBusy: isBusy
        };
      }

      var XML_NAME_SPACE = "http://www.w3.org/2000/svg";
      var PATH = "m15.5 0.932-4.3 4.38 14.5 14.6-14.5 14.5 4.3 4.4 14.6-14.6 4.4-4.3-4.4-4.4-14.6-14.6z";
      var SIZE = 40;

      function Arrows(Splide2, Components2, options) {
        var event = EventInterface(Splide2);
        var on = event.on,
          bind = event.bind,
          emit = event.emit;
        var classes = options.classes,
          i18n = options.i18n;
        var Elements = Components2.Elements,
          Controller = Components2.Controller;
        var placeholder = Elements.arrows,
          track = Elements.track;
        var wrapper = placeholder;
        var prev = Elements.prev;
        var next = Elements.next;
        var created;
        var wrapperClasses;
        var arrows = {};

        function mount() {
          init();
          on(EVENT_UPDATED, remount);
        }

        function remount() {
          destroy();
          mount();
        }

        function init() {
          var enabled = options.arrows;

          if (enabled && !(prev && next)) {
            createArrows();
          }

          if (prev && next) {
            assign(arrows, {
              prev: prev,
              next: next
            });
            display(wrapper, enabled ? "" : "none");
            addClass(wrapper, wrapperClasses = CLASS_ARROWS + "--" + options.direction);

            if (enabled) {
              listen();
              update();
              setAttribute([prev, next], ARIA_CONTROLS, track.id);
              emit(EVENT_ARROWS_MOUNTED, prev, next);
            }
          }
        }

        function destroy() {
          event.destroy();
          removeClass(wrapper, wrapperClasses);

          if (created) {
            remove(placeholder ? [prev, next] : wrapper);
            prev = next = null;
          } else {
            removeAttribute([prev, next], ALL_ATTRIBUTES);
          }
        }

        function listen() {
          on([EVENT_MOUNTED, EVENT_MOVED, EVENT_REFRESH, EVENT_SCROLLED, EVENT_END_INDEX_CHANGED], update);
          bind(next, "click", apply(go, ">"));
          bind(prev, "click", apply(go, "<"));
        }

        function go(control) {
          Controller.go(control, true);
        }

        function createArrows() {
          wrapper = placeholder || create("div", classes.arrows);
          prev = createArrow(true);
          next = createArrow(false);
          created = true;
          append(wrapper, [prev, next]);
          !placeholder && before(wrapper, track);
        }

        function createArrow(prev2) {
          var arrow = "<button class=\"" + classes.arrow + " " + (prev2 ? classes.prev : classes.next) + "\" type=\"button\"><svg xmlns=\"" + XML_NAME_SPACE + "\" viewBox=\"0 0 " + SIZE + " " + SIZE + "\" width=\"" + SIZE + "\" height=\"" + SIZE + "\" focusable=\"false\"><path d=\"" + (options.arrowPath || PATH) + "\" />";
          return parseHtml(arrow);
        }

        function update() {
          if (prev && next) {
            var index = Splide2.index;
            var prevIndex = Controller.getPrev();
            var nextIndex = Controller.getNext();
            var prevLabel = prevIndex > -1 && index < prevIndex ? i18n.last : i18n.prev;
            var nextLabel = nextIndex > -1 && index > nextIndex ? i18n.first : i18n.next;
            prev.disabled = prevIndex < 0;
            next.disabled = nextIndex < 0;
            setAttribute(prev, ARIA_LABEL, prevLabel);
            setAttribute(next, ARIA_LABEL, nextLabel);
            emit(EVENT_ARROWS_UPDATED, prev, next, prevIndex, nextIndex);
          }
        }

        return {
          arrows: arrows,
          mount: mount,
          destroy: destroy,
          update: update
        };
      }

      var INTERVAL_DATA_ATTRIBUTE = DATA_ATTRIBUTE + "-interval";

      function Autoplay(Splide2, Components2, options) {
        var _EventInterface6 = EventInterface(Splide2),
          on = _EventInterface6.on,
          bind = _EventInterface6.bind,
          emit = _EventInterface6.emit;

        var interval = RequestInterval(options.interval, Splide2.go.bind(Splide2, ">"), onAnimationFrame);
        var isPaused = interval.isPaused;
        var Elements = Components2.Elements,
          _Components2$Elements4 = Components2.Elements,
          root = _Components2$Elements4.root,
          toggle = _Components2$Elements4.toggle;
        var autoplay = options.autoplay;
        var hovered;
        var focused;
        var stopped = autoplay === "pause";

        function mount() {
          if (autoplay) {
            listen();
            toggle && setAttribute(toggle, ARIA_CONTROLS, Elements.track.id);
            stopped || play();
            update();
          }
        }

        function listen() {
          if (options.pauseOnHover) {
            bind(root, "mouseenter mouseleave", function (e) {
              hovered = e.type === "mouseenter";
              autoToggle();
            });
          }

          if (options.pauseOnFocus) {
            bind(root, "focusin focusout", function (e) {
              focused = e.type === "focusin";
              autoToggle();
            });
          }

          if (toggle) {
            bind(toggle, "click", function () {
              stopped ? play() : pause(true);
            });
          }

          on([EVENT_MOVE, EVENT_SCROLL, EVENT_REFRESH], interval.rewind);
          on(EVENT_MOVE, onMove);
        }

        function play() {
          if (isPaused() && Components2.Slides.isEnough()) {
            interval.start(!options.resetProgress);
            focused = hovered = stopped = false;
            update();
            emit(EVENT_AUTOPLAY_PLAY);
          }
        }

        function pause(stop) {
          if (stop === void 0) {
            stop = true;
          }

          stopped = !!stop;
          update();

          if (!isPaused()) {
            interval.pause();
            emit(EVENT_AUTOPLAY_PAUSE);
          }
        }

        function autoToggle() {
          if (!stopped) {
            hovered || focused ? pause(false) : play();
          }
        }

        function update() {
          if (toggle) {
            toggleClass(toggle, CLASS_ACTIVE, !stopped);
            setAttribute(toggle, ARIA_LABEL, options.i18n[stopped ? "play" : "pause"]);
          }
        }

        function onAnimationFrame(rate) {
          var bar = Elements.bar;
          bar && style(bar, "width", rate * 100 + "%");
          emit(EVENT_AUTOPLAY_PLAYING, rate);
        }

        function onMove(index) {
          var Slide = Components2.Slides.getAt(index);
          interval.set(Slide && +getAttribute(Slide.slide, INTERVAL_DATA_ATTRIBUTE) || options.interval);
        }

        return {
          mount: mount,
          destroy: interval.cancel,
          play: play,
          pause: pause,
          isPaused: isPaused
        };
      }

      function Cover(Splide2, Components2, options) {
        var _EventInterface7 = EventInterface(Splide2),
          on = _EventInterface7.on;

        function mount() {
          if (options.cover) {
            on(EVENT_LAZYLOAD_LOADED, apply(toggle, true));
            on([EVENT_MOUNTED, EVENT_UPDATED, EVENT_REFRESH], apply(cover, true));
          }
        }

        function cover(cover2) {
          Components2.Slides.forEach(function (Slide) {
            var img = child(Slide.container || Slide.slide, "img");

            if (img && img.src) {
              toggle(cover2, img, Slide);
            }
          });
        }

        function toggle(cover2, img, Slide) {
          Slide.style("background", cover2 ? "center/cover no-repeat url(\"" + img.src + "\")" : "", true);
          display(img, cover2 ? "none" : "");
        }

        return {
          mount: mount,
          destroy: apply(cover, false)
        };
      }

      var BOUNCE_DIFF_THRESHOLD = 10;
      var BOUNCE_DURATION = 600;
      var FRICTION_FACTOR = 0.6;
      var BASE_VELOCITY = 1.5;
      var MIN_DURATION = 800;

      function Scroll(Splide2, Components2, options) {
        var _EventInterface8 = EventInterface(Splide2),
          on = _EventInterface8.on,
          emit = _EventInterface8.emit;

        var set = Splide2.state.set;
        var Move = Components2.Move;
        var getPosition = Move.getPosition,
          getLimit = Move.getLimit,
          exceededLimit = Move.exceededLimit,
          translate = Move.translate;
        var isSlide = Splide2.is(SLIDE);
        var interval;
        var callback;
        var friction = 1;

        function mount() {
          on(EVENT_MOVE, clear);
          on([EVENT_UPDATED, EVENT_REFRESH], cancel);
        }

        function scroll(destination, duration, snap, onScrolled, noConstrain) {
          var from = getPosition();
          clear();

          if (snap && (!isSlide || !exceededLimit())) {
            var size = Components2.Layout.sliderSize();
            var offset = sign(destination) * size * floor(abs(destination) / size) || 0;
            destination = Move.toPosition(Components2.Controller.toDest(destination % size)) + offset;
          }

          var noDistance = approximatelyEqual(from, destination, 1);
          friction = 1;
          duration = noDistance ? 0 : duration || max(abs(destination - from) / BASE_VELOCITY, MIN_DURATION);
          callback = onScrolled;
          interval = RequestInterval(duration, onEnd, apply(update, from, destination, noConstrain), 1);
          set(SCROLLING);
          emit(EVENT_SCROLL);
          interval.start();
        }

        function onEnd() {
          set(IDLE);
          callback && callback();
          emit(EVENT_SCROLLED);
        }

        function update(from, to, noConstrain, rate) {
          var position = getPosition();
          var target = from + (to - from) * easing(rate);
          var diff = (target - position) * friction;
          translate(position + diff);

          if (isSlide && !noConstrain && exceededLimit()) {
            friction *= FRICTION_FACTOR;

            if (abs(diff) < BOUNCE_DIFF_THRESHOLD) {
              scroll(getLimit(exceededLimit(true)), BOUNCE_DURATION, false, callback, true);
            }
          }
        }

        function clear() {
          if (interval) {
            interval.cancel();
          }
        }

        function cancel() {
          if (interval && !interval.isPaused()) {
            clear();
            onEnd();
          }
        }

        function easing(t) {
          var easingFunc = options.easingFunc;
          return easingFunc ? easingFunc(t) : 1 - Math.pow(1 - t, 4);
        }

        return {
          mount: mount,
          destroy: clear,
          scroll: scroll,
          cancel: cancel
        };
      }

      var SCROLL_LISTENER_OPTIONS = {
        passive: false,
        capture: true
      };

      function Drag(Splide2, Components2, options) {
        var _EventInterface9 = EventInterface(Splide2),
          on = _EventInterface9.on,
          emit = _EventInterface9.emit,
          bind = _EventInterface9.bind,
          unbind = _EventInterface9.unbind;

        var state = Splide2.state;
        var Move = Components2.Move,
          Scroll = Components2.Scroll,
          Controller = Components2.Controller,
          track = Components2.Elements.track,
          reduce = Components2.Media.reduce;
        var _Components2$Directio2 = Components2.Direction,
          resolve = _Components2$Directio2.resolve,
          orient = _Components2$Directio2.orient;
        var getPosition = Move.getPosition,
          exceededLimit = Move.exceededLimit;
        var basePosition;
        var baseEvent;
        var prevBaseEvent;
        var isFree;
        var dragging;
        var exceeded = false;
        var clickPrevented;
        var disabled;
        var target;

        function mount() {
          bind(track, POINTER_MOVE_EVENTS, noop, SCROLL_LISTENER_OPTIONS);
          bind(track, POINTER_UP_EVENTS, noop, SCROLL_LISTENER_OPTIONS);
          bind(track, POINTER_DOWN_EVENTS, onPointerDown, SCROLL_LISTENER_OPTIONS);
          bind(track, "click", onClick, {
            capture: true
          });
          bind(track, "dragstart", prevent);
          on([EVENT_MOUNTED, EVENT_UPDATED], init);
        }

        function init() {
          var drag = options.drag;
          disable(!drag);
          isFree = drag === "free";
        }

        function onPointerDown(e) {
          clickPrevented = false;

          if (!disabled) {
            var isTouch = isTouchEvent(e);

            if (isDraggable(e.target) && (isTouch || !e.button)) {
              if (!Controller.isBusy()) {
                target = isTouch ? track : window;
                dragging = state.is([MOVING, SCROLLING]);
                prevBaseEvent = null;
                bind(target, POINTER_MOVE_EVENTS, onPointerMove, SCROLL_LISTENER_OPTIONS);
                bind(target, POINTER_UP_EVENTS, onPointerUp, SCROLL_LISTENER_OPTIONS);
                Move.cancel();
                Scroll.cancel();
                save(e);
              } else {
                prevent(e, true);
              }
            }
          }
        }

        function onPointerMove(e) {
          if (!state.is(DRAGGING)) {
            state.set(DRAGGING);
            emit(EVENT_DRAG);
          }

          if (e.cancelable) {
            if (dragging) {
              Move.translate(basePosition + constrain(diffCoord(e)));
              var expired = diffTime(e) > LOG_INTERVAL;
              var hasExceeded = exceeded !== (exceeded = exceededLimit());

              if (expired || hasExceeded) {
                save(e);
              }

              clickPrevented = true;
              emit(EVENT_DRAGGING);
              prevent(e);
            } else if (isSliderDirection(e)) {
              dragging = shouldStart(e);
              prevent(e);
            }
          }
        }

        function onPointerUp(e) {
          if (state.is(DRAGGING)) {
            state.set(IDLE);
            emit(EVENT_DRAGGED);
          }

          if (dragging) {
            move(e);
            prevent(e);
          }

          unbind(target, POINTER_MOVE_EVENTS, onPointerMove);
          unbind(target, POINTER_UP_EVENTS, onPointerUp);
          dragging = false;
        }

        function onClick(e) {
          if (!disabled && clickPrevented) {
            prevent(e, true);
          }
        }

        function save(e) {
          prevBaseEvent = baseEvent;
          baseEvent = e;
          basePosition = getPosition();
        }

        function move(e) {
          var velocity = computeVelocity(e);
          var destination = computeDestination(velocity);
          var rewind = options.rewind && options.rewindByDrag;
          reduce(false);

          if (isFree) {
            Controller.scroll(destination, 0, options.snap);
          } else if (Splide2.is(FADE)) {
            Controller.go(orient(sign(velocity)) < 0 ? rewind ? "<" : "-" : rewind ? ">" : "+");
          } else if (Splide2.is(SLIDE) && exceeded && rewind) {
            Controller.go(exceededLimit(true) ? ">" : "<");
          } else {
            Controller.go(Controller.toDest(destination), true);
          }

          reduce(true);
        }

        function shouldStart(e) {
          var thresholds = options.dragMinThreshold;
          var isObj = isObject(thresholds);
          var mouse = isObj && thresholds.mouse || 0;
          var touch = (isObj ? thresholds.touch : +thresholds) || 10;
          return abs(diffCoord(e)) > (isTouchEvent(e) ? touch : mouse);
        }

        function isSliderDirection(e) {
          return abs(diffCoord(e)) > abs(diffCoord(e, true));
        }

        function computeVelocity(e) {
          if (Splide2.is(LOOP) || !exceeded) {
            var time = diffTime(e);

            if (time && time < LOG_INTERVAL) {
              return diffCoord(e) / time;
            }
          }

          return 0;
        }

        function computeDestination(velocity) {
          return getPosition() + sign(velocity) * min(abs(velocity) * (options.flickPower || 600), isFree ? Infinity : Components2.Layout.listSize() * (options.flickMaxPages || 1));
        }

        function diffCoord(e, orthogonal) {
          return coordOf(e, orthogonal) - coordOf(getBaseEvent(e), orthogonal);
        }

        function diffTime(e) {
          return timeOf(e) - timeOf(getBaseEvent(e));
        }

        function getBaseEvent(e) {
          return baseEvent === e && prevBaseEvent || baseEvent;
        }

        function coordOf(e, orthogonal) {
          return (isTouchEvent(e) ? e.changedTouches[0] : e)["page" + resolve(orthogonal ? "Y" : "X")];
        }

        function constrain(diff) {
          return diff / (exceeded && Splide2.is(SLIDE) ? FRICTION : 1);
        }

        function isDraggable(target2) {
          var noDrag = options.noDrag;
          return !matches(target2, "." + CLASS_PAGINATION_PAGE + ", ." + CLASS_ARROW) && (!noDrag || !matches(target2, noDrag));
        }

        function isTouchEvent(e) {
          return typeof TouchEvent !== "undefined" && e instanceof TouchEvent;
        }

        function isDragging() {
          return dragging;
        }

        function disable(value) {
          disabled = value;
        }

        return {
          mount: mount,
          disable: disable,
          isDragging: isDragging
        };
      }

      var NORMALIZATION_MAP = {
        Spacebar: " ",
        Right: ARROW_RIGHT,
        Left: ARROW_LEFT,
        Up: ARROW_UP,
        Down: ARROW_DOWN
      };

      function normalizeKey(key) {
        key = isString(key) ? key : key.key;
        return NORMALIZATION_MAP[key] || key;
      }

      var KEYBOARD_EVENT = "keydown";

      function Keyboard(Splide2, Components2, options) {
        var _EventInterface10 = EventInterface(Splide2),
          on = _EventInterface10.on,
          bind = _EventInterface10.bind,
          unbind = _EventInterface10.unbind;

        var root = Splide2.root;
        var resolve = Components2.Direction.resolve;
        var target;
        var disabled;

        function mount() {
          init();
          on(EVENT_UPDATED, destroy);
          on(EVENT_UPDATED, init);
          on(EVENT_MOVE, onMove);
        }

        function init() {
          var keyboard = options.keyboard;

          if (keyboard) {
            target = keyboard === "global" ? window : root;
            bind(target, KEYBOARD_EVENT, onKeydown);
          }
        }

        function destroy() {
          unbind(target, KEYBOARD_EVENT);
        }

        function disable(value) {
          disabled = value;
        }

        function onMove() {
          var _disabled = disabled;
          disabled = true;
          nextTick(function () {
            disabled = _disabled;
          });
        }

        function onKeydown(e) {
          if (!disabled) {
            var key = normalizeKey(e);

            if (key === resolve(ARROW_LEFT)) {
              Splide2.go("<");
            } else if (key === resolve(ARROW_RIGHT)) {
              Splide2.go(">");
            }
          }
        }

        return {
          mount: mount,
          destroy: destroy,
          disable: disable
        };
      }

      var SRC_DATA_ATTRIBUTE = DATA_ATTRIBUTE + "-lazy";
      var SRCSET_DATA_ATTRIBUTE = SRC_DATA_ATTRIBUTE + "-srcset";
      var IMAGE_SELECTOR = "[" + SRC_DATA_ATTRIBUTE + "], [" + SRCSET_DATA_ATTRIBUTE + "]";

      function LazyLoad(Splide2, Components2, options) {
        var _EventInterface11 = EventInterface(Splide2),
          on = _EventInterface11.on,
          off = _EventInterface11.off,
          bind = _EventInterface11.bind,
          emit = _EventInterface11.emit;

        var isSequential = options.lazyLoad === "sequential";
        var events = [EVENT_MOVED, EVENT_SCROLLED];
        var entries = [];

        function mount() {
          if (options.lazyLoad) {
            init();
            on(EVENT_REFRESH, init);
          }
        }

        function init() {
          empty(entries);
          register();

          if (isSequential) {
            loadNext();
          } else {
            off(events);
            on(events, check);
            check();
          }
        }

        function register() {
          Components2.Slides.forEach(function (Slide) {
            queryAll(Slide.slide, IMAGE_SELECTOR).forEach(function (img) {
              var src = getAttribute(img, SRC_DATA_ATTRIBUTE);
              var srcset = getAttribute(img, SRCSET_DATA_ATTRIBUTE);

              if (src !== img.src || srcset !== img.srcset) {
                var className = options.classes.spinner;
                var parent = img.parentElement;
                var spinner = child(parent, "." + className) || create("span", className, parent);
                entries.push([img, Slide, spinner]);
                img.src || display(img, "none");
              }
            });
          });
        }

        function check() {
          entries = entries.filter(function (data) {
            var distance = options.perPage * ((options.preloadPages || 1) + 1) - 1;
            return data[1].isWithin(Splide2.index, distance) ? load(data) : true;
          });
          entries.length || off(events);
        }

        function load(data) {
          var img = data[0];
          addClass(data[1].slide, CLASS_LOADING);
          bind(img, "load error", apply(onLoad, data));
          setAttribute(img, "src", getAttribute(img, SRC_DATA_ATTRIBUTE));
          setAttribute(img, "srcset", getAttribute(img, SRCSET_DATA_ATTRIBUTE));
          removeAttribute(img, SRC_DATA_ATTRIBUTE);
          removeAttribute(img, SRCSET_DATA_ATTRIBUTE);
        }

        function onLoad(data, e) {
          var img = data[0],
            Slide = data[1];
          removeClass(Slide.slide, CLASS_LOADING);

          if (e.type !== "error") {
            remove(data[2]);
            display(img, "");
            emit(EVENT_LAZYLOAD_LOADED, img, Slide);
            emit(EVENT_RESIZE);
          }

          isSequential && loadNext();
        }

        function loadNext() {
          entries.length && load(entries.shift());
        }

        return {
          mount: mount,
          destroy: apply(empty, entries),
          check: check
        };
      }

      function Pagination(Splide2, Components2, options) {
        var event = EventInterface(Splide2);
        var on = event.on,
          emit = event.emit,
          bind = event.bind;
        var Slides = Components2.Slides,
          Elements = Components2.Elements,
          Controller = Components2.Controller;
        var hasFocus = Controller.hasFocus,
          getIndex = Controller.getIndex,
          go = Controller.go;
        var resolve = Components2.Direction.resolve;
        var placeholder = Elements.pagination;
        var items = [];
        var list;
        var paginationClasses;

        function mount() {
          destroy();
          on([EVENT_UPDATED, EVENT_REFRESH, EVENT_END_INDEX_CHANGED], mount);
          var enabled = options.pagination;
          placeholder && display(placeholder, enabled ? "" : "none");

          if (enabled) {
            on([EVENT_MOVE, EVENT_SCROLL, EVENT_SCROLLED], update);
            createPagination();
            update();
            emit(EVENT_PAGINATION_MOUNTED, {
              list: list,
              items: items
            }, getAt(Splide2.index));
          }
        }

        function destroy() {
          if (list) {
            remove(placeholder ? slice(list.children) : list);
            removeClass(list, paginationClasses);
            empty(items);
            list = null;
          }

          event.destroy();
        }

        function createPagination() {
          var length = Splide2.length;
          var classes = options.classes,
            i18n = options.i18n,
            perPage = options.perPage;
          var max = hasFocus() ? Controller.getEnd() + 1 : ceil(length / perPage);
          list = placeholder || create("ul", classes.pagination, Elements.track.parentElement);
          addClass(list, paginationClasses = CLASS_PAGINATION + "--" + getDirection());
          setAttribute(list, ROLE, "tablist");
          setAttribute(list, ARIA_LABEL, i18n.select);
          setAttribute(list, ARIA_ORIENTATION, getDirection() === TTB ? "vertical" : "");

          for (var i = 0; i < max; i++) {
            var li = create("li", null, list);
            var button = create("button", {
              class: classes.page,
              type: "button"
            }, li);
            var controls = Slides.getIn(i).map(function (Slide) {
              return Slide.slide.id;
            });
            var text = !hasFocus() && perPage > 1 ? i18n.pageX : i18n.slideX;
            bind(button, "click", apply(onClick, i));

            if (options.paginationKeyboard) {
              bind(button, "keydown", apply(onKeydown, i));
            }

            setAttribute(li, ROLE, "presentation");
            setAttribute(button, ROLE, "tab");
            setAttribute(button, ARIA_CONTROLS, controls.join(" "));
            setAttribute(button, ARIA_LABEL, format(text, i + 1));
            setAttribute(button, TAB_INDEX, -1);
            items.push({
              li: li,
              button: button,
              page: i
            });
          }
        }

        function onClick(page) {
          go(">" + page, true);
        }

        function onKeydown(page, e) {
          var length = items.length;
          var key = normalizeKey(e);
          var dir = getDirection();
          var nextPage = -1;

          if (key === resolve(ARROW_RIGHT, false, dir)) {
            nextPage = ++page % length;
          } else if (key === resolve(ARROW_LEFT, false, dir)) {
            nextPage = (--page + length) % length;
          } else if (key === "Home") {
            nextPage = 0;
          } else if (key === "End") {
            nextPage = length - 1;
          }

          var item = items[nextPage];

          if (item) {
            focus(item.button);
            go(">" + nextPage);
            prevent(e, true);
          }
        }

        function getDirection() {
          return options.paginationDirection || options.direction;
        }

        function getAt(index) {
          return items[Controller.toPage(index)];
        }

        function update() {
          var prev = getAt(getIndex(true));
          var curr = getAt(getIndex());

          if (prev) {
            var button = prev.button;
            removeClass(button, CLASS_ACTIVE);
            removeAttribute(button, ARIA_SELECTED);
            setAttribute(button, TAB_INDEX, -1);
          }

          if (curr) {
            var _button = curr.button;
            addClass(_button, CLASS_ACTIVE);
            setAttribute(_button, ARIA_SELECTED, true);
            setAttribute(_button, TAB_INDEX, "");
          }

          emit(EVENT_PAGINATION_UPDATED, {
            list: list,
            items: items
          }, prev, curr);
        }

        return {
          items: items,
          mount: mount,
          destroy: destroy,
          getAt: getAt,
          update: update
        };
      }

      var TRIGGER_KEYS = [" ", "Enter"];

      function Sync(Splide2, Components2, options) {
        var isNavigation = options.isNavigation,
          slideFocus = options.slideFocus;
        var events = [];

        function mount() {
          Splide2.splides.forEach(function (target) {
            if (!target.isParent) {
              sync(Splide2, target.splide);
              sync(target.splide, Splide2);
            }
          });

          if (isNavigation) {
            navigate();
          }
        }

        function destroy() {
          events.forEach(function (event) {
            event.destroy();
          });
          empty(events);
        }

        function remount() {
          destroy();
          mount();
        }

        function sync(splide, target) {
          var event = EventInterface(splide);
          event.on(EVENT_MOVE, function (index, prev, dest) {
            target.go(target.is(LOOP) ? dest : index);
          });
          events.push(event);
        }

        function navigate() {
          var event = EventInterface(Splide2);
          var on = event.on;
          on(EVENT_CLICK, onClick);
          on(EVENT_SLIDE_KEYDOWN, onKeydown);
          on([EVENT_MOUNTED, EVENT_UPDATED], update);
          events.push(event);
          event.emit(EVENT_NAVIGATION_MOUNTED, Splide2.splides);
        }

        function update() {
          setAttribute(Components2.Elements.list, ARIA_ORIENTATION, options.direction === TTB ? "vertical" : "");
        }

        function onClick(Slide) {
          Splide2.go(Slide.index);
        }

        function onKeydown(Slide, e) {
          if (includes(TRIGGER_KEYS, normalizeKey(e))) {
            onClick(Slide);
            prevent(e);
          }
        }

        return {
          setup: apply(Components2.Media.set, {
            slideFocus: isUndefined(slideFocus) ? isNavigation : slideFocus
          }, true),
          mount: mount,
          destroy: destroy,
          remount: remount
        };
      }

      function Wheel(Splide2, Components2, options) {
        var _EventInterface12 = EventInterface(Splide2),
          bind = _EventInterface12.bind;

        var lastTime = 0;

        function mount() {
          if (options.wheel) {
            bind(Components2.Elements.track, "wheel", onWheel, SCROLL_LISTENER_OPTIONS);
          }
        }

        function onWheel(e) {
          if (e.cancelable) {
            var deltaY = e.deltaY;
            var backwards = deltaY < 0;
            var timeStamp = timeOf(e);

            var _min = options.wheelMinThreshold || 0;

            var sleep = options.wheelSleep || 0;

            if (abs(deltaY) > _min && timeStamp - lastTime > sleep) {
              Splide2.go(backwards ? "<" : ">");
              lastTime = timeStamp;
            }

            shouldPrevent(backwards) && prevent(e);
          }
        }

        function shouldPrevent(backwards) {
          return !options.releaseWheel || Splide2.state.is(MOVING) || Components2.Controller.getAdjacent(backwards) !== -1;
        }

        return {
          mount: mount
        };
      }

      var SR_REMOVAL_DELAY = 90;

      function Live(Splide2, Components2, options) {
        var _EventInterface13 = EventInterface(Splide2),
          on = _EventInterface13.on;

        var track = Components2.Elements.track;
        var enabled = options.live && !options.isNavigation;
        var sr = create("span", CLASS_SR);
        var interval = RequestInterval(SR_REMOVAL_DELAY, apply(toggle, false));

        function mount() {
          if (enabled) {
            disable(!Components2.Autoplay.isPaused());
            setAttribute(track, ARIA_ATOMIC, true);
            sr.textContent = "\u2026";
            on(EVENT_AUTOPLAY_PLAY, apply(disable, true));
            on(EVENT_AUTOPLAY_PAUSE, apply(disable, false));
            on([EVENT_MOVED, EVENT_SCROLLED], apply(toggle, true));
          }
        }

        function toggle(active) {
          setAttribute(track, ARIA_BUSY, active);

          if (active) {
            append(track, sr);
            interval.start();
          } else {
            remove(sr);
            interval.cancel();
          }
        }

        function destroy() {
          removeAttribute(track, [ARIA_LIVE, ARIA_ATOMIC, ARIA_BUSY]);
          remove(sr);
        }

        function disable(disabled) {
          if (enabled) {
            setAttribute(track, ARIA_LIVE, disabled ? "off" : "polite");
          }
        }

        return {
          mount: mount,
          disable: disable,
          destroy: destroy
        };
      }

      var ComponentConstructors = /*#__PURE__*/Object.freeze({
        __proto__: null,
        Media: Media,
        Direction: Direction,
        Elements: Elements,
        Slides: Slides,
        Layout: Layout,
        Clones: Clones,
        Move: Move,
        Controller: Controller,
        Arrows: Arrows,
        Autoplay: Autoplay,
        Cover: Cover,
        Scroll: Scroll,
        Drag: Drag,
        Keyboard: Keyboard,
        LazyLoad: LazyLoad,
        Pagination: Pagination,
        Sync: Sync,
        Wheel: Wheel,
        Live: Live
      });
      var I18N = {
        prev: "Previous slide",
        next: "Next slide",
        first: "Go to first slide",
        last: "Go to last slide",
        slideX: "Go to slide %s",
        pageX: "Go to page %s",
        play: "Start autoplay",
        pause: "Pause autoplay",
        carousel: "carousel",
        slide: "slide",
        select: "Select a slide to show",
        slideLabel: "%s of %s"
      };
      var DEFAULTS = {
        type: "slide",
        role: "region",
        speed: 400,
        perPage: 1,
        cloneStatus: true,
        arrows: true,
        pagination: true,
        paginationKeyboard: true,
        interval: 5e3,
        pauseOnHover: true,
        pauseOnFocus: true,
        resetProgress: true,
        easing: "cubic-bezier(0.25, 1, 0.5, 1)",
        drag: true,
        direction: "ltr",
        trimSpace: true,
        focusableNodes: "a, button, textarea, input, select, iframe",
        live: true,
        classes: CLASSES,
        i18n: I18N,
        reducedMotion: {
          speed: 0,
          rewindSpeed: 0,
          autoplay: "pause"
        }
      };

      function Fade(Splide2, Components2, options) {
        var Slides = Components2.Slides;

        function mount() {
          EventInterface(Splide2).on([EVENT_MOUNTED, EVENT_REFRESH], init);
        }

        function init() {
          Slides.forEach(function (Slide) {
            Slide.style("transform", "translateX(-" + 100 * Slide.index + "%)");
          });
        }

        function start(index, done) {
          Slides.style("transition", "opacity " + options.speed + "ms " + options.easing);
          nextTick(done);
        }

        return {
          mount: mount,
          start: start,
          cancel: noop
        };
      }

      function Slide(Splide2, Components2, options) {
        var Move = Components2.Move,
          Controller = Components2.Controller,
          Scroll = Components2.Scroll;
        var list = Components2.Elements.list;
        var transition = apply(style, list, "transition");
        var endCallback;

        function mount() {
          EventInterface(Splide2).bind(list, "transitionend", function (e) {
            if (e.target === list && endCallback) {
              cancel();
              endCallback();
            }
          });
        }

        function start(index, done) {
          var destination = Move.toPosition(index, true);
          var position = Move.getPosition();
          var speed = getSpeed(index);

          if (abs(destination - position) >= 1 && speed >= 1) {
            if (options.useScroll) {
              Scroll.scroll(destination, speed, false, done);
            } else {
              transition("transform " + speed + "ms " + options.easing);
              Move.translate(destination, true);
              endCallback = done;
            }
          } else {
            Move.jump(index);
            done();
          }
        }

        function cancel() {
          transition("");
          Scroll.cancel();
        }

        function getSpeed(index) {
          var rewindSpeed = options.rewindSpeed;

          if (Splide2.is(SLIDE) && rewindSpeed) {
            var prev = Controller.getIndex(true);
            var end = Controller.getEnd();

            if (prev === 0 && index >= end || prev >= end && index === 0) {
              return rewindSpeed;
            }
          }

          return options.speed;
        }

        return {
          mount: mount,
          start: start,
          cancel: cancel
        };
      }

      var _Splide = /*#__PURE__*/function () {
        function _Splide(target, options) {
          this.event = EventInterface();
          this.Components = {};
          this.state = State(CREATED);
          this.splides = [];
          this._o = {};
          this._E = {};
          var root = isString(target) ? query(document, target) : target;
          assert(root, root + " is invalid.");
          this.root = root;
          options = merge({
            label: getAttribute(root, ARIA_LABEL) || "",
            labelledby: getAttribute(root, ARIA_LABELLEDBY) || ""
          }, DEFAULTS, _Splide.defaults, options || {});

          try {
            merge(options, JSON.parse(getAttribute(root, DATA_ATTRIBUTE)));
          } catch (e) {
            assert(false, "Invalid JSON");
          }

          this._o = Object.create(merge({}, options));
        }

        var _proto = _Splide.prototype;

        _proto.mount = function mount(Extensions, Transition) {
          var _this = this;

          var state = this.state,
            Components2 = this.Components;
          assert(state.is([CREATED, DESTROYED]), "Already mounted!");
          state.set(CREATED);
          this._C = Components2;
          this._T = Transition || this._T || (this.is(FADE) ? Fade : Slide);
          this._E = Extensions || this._E;
          var Constructors = assign({}, ComponentConstructors, this._E, {
            Transition: this._T
          });
          forOwn(Constructors, function (Component, key) {
            var component = Component(_this, Components2, _this._o);
            Components2[key] = component;
            component.setup && component.setup();
          });
          forOwn(Components2, function (component) {
            component.mount && component.mount();
          });
          this.emit(EVENT_MOUNTED);
          addClass(this.root, CLASS_INITIALIZED);
          state.set(IDLE);
          this.emit(EVENT_READY);
          return this;
        };

        _proto.sync = function sync(splide) {
          this.splides.push({
            splide: splide
          });
          splide.splides.push({
            splide: this,
            isParent: true
          });

          if (this.state.is(IDLE)) {
            this._C.Sync.remount();

            splide.Components.Sync.remount();
          }

          return this;
        };

        _proto.go = function go(control) {
          this._C.Controller.go(control);

          return this;
        };

        _proto.on = function on(events, callback) {
          this.event.on(events, callback);
          return this;
        };

        _proto.off = function off(events) {
          this.event.off(events);
          return this;
        };

        _proto.emit = function emit(event) {
          var _this$event;

          (_this$event = this.event).emit.apply(_this$event, [event].concat(slice(arguments, 1)));

          return this;
        };

        _proto.add = function add(slides, index) {
          this._C.Slides.add(slides, index);

          return this;
        };

        _proto.remove = function remove(matcher) {
          this._C.Slides.remove(matcher);

          return this;
        };

        _proto.is = function is(type) {
          return this._o.type === type;
        };

        _proto.refresh = function refresh() {
          this.emit(EVENT_REFRESH);
          return this;
        };

        _proto.destroy = function destroy(completely) {
          if (completely === void 0) {
            completely = true;
          }

          var event = this.event,
            state = this.state;

          if (state.is(CREATED)) {
            EventInterface(this).on(EVENT_READY, this.destroy.bind(this, completely));
          } else {
            forOwn(this._C, function (component) {
              component.destroy && component.destroy(completely);
            }, true);
            event.emit(EVENT_DESTROY);
            event.destroy();
            completely && empty(this.splides);
            state.set(DESTROYED);
          }

          return this;
        };

        _createClass(_Splide, [{
          key: "options",
          get: function get() {
            return this._o;
          },
          set: function set(options) {
            this._C.Media.set(options, true, true);
          }
        }, {
          key: "length",
          get: function get() {
            return this._C.Slides.getLength(true);
          }
        }, {
          key: "index",
          get: function get() {
            return this._C.Controller.getIndex();
          }
        }]);

        return _Splide;
      }();

      var Splide = _Splide;
      Splide.defaults = {};
      Splide.STATES = STATES;
      return Splide;
    });
  </script>
  <script>
    var displayItems = []
    var splide // to make it global
    var displayItemSequence = [] // for shuffling
    var fontSizeAdjustDelay

    function pageLoad() {
      if (gameSettings.category.length > 0){
        gameSettings.categories = gameSettings.category.split(/\s*,\s*/)
      } else {
        gameSettings.categories = []
      }
      updateSettingsFromURL()      

      setColorTheme(gameSettings.color)

      establishHeaderAndFooter()

      establishLogo()

      document.body.style.fontSize = gameSettings.fontSize/100 + 'em'

      // can remove this from the part later on?
      if (gameSettings.border == 'thick') {
        document.body.classList.add('border')
      } else if (gameSettings.border == 'hairline'){
        document.body.classList.add('border')
        document.body.classList.add('border-hairline')
      } else if (gameSettings.border == 'rounded'){
        document.body.classList.add('border')
        document.body.classList.add('border-rounded')
      }

      document.getElementById('pickButton').innerHTML = gameSettings.pickerText

      sortDisplayItems()

      let splideTrack = document.getElementById('splideTrack')

      let splideList = newElement('ul', { class: 'splide__list' })

      splideTrack.appendChild(splideList)

      splide = new Splide('.splide', {
        focus: 'center',
        rewind: true,
        trimSpace: false,
        speed: 800,
        autoWidth: true,
        autoplay: gameSettings.autoAdvance,
        interval: gameSettings.autoAdvanceDelay * 1000,
        pauseOnHover: true,
        pagination: (gameSettings.navigation && !gameSettings.picker),
        slideFocus: gameSettings.navigation,
        flickPower: 50,
        flickMaxPages: 1,
        focusableNodes: 'a, button, textarea, input, select, iframe',
        arrows: gameSettings.navigation
      });

      splide.on('move', () => {
        restyleItems(splide.index)
      })

      gameData.forEach(item => {
        let skip = false
        let itemURL = ''

        // check "show from" date
        if (item.length > 2
          && item[2].datetime.length > 0
          && isFutureDate(item[2].datetime)) {
          skip = true
        }

        // check "show until" date
        if (item.length > 3
          && item[3].datetime.length > 0
          && isPastDate(item[3].datetime)) {
          skip = true
        }

        if(gameSettings.categories.length > 0 && item.length > 4 && item[4].length > 0 && !gameSettings.categories.includes(item[4])){
          // if we're using categories and this item is not in the list, then skip
          skip = true
        }

        if (!skip) {
          el = newElement('li', { class: 'splide__slide display-item left up ' + (gameSettings.backMode == 'autoUnder' ? 'under' : gameSettings.backMode), dataIndex: displayItems.length, onclick: `handleItemClick(${displayItems.length}, event)`, onkeypress: `handleKeyPress(event,this)` })
          // el = newElement('li',{class: 'splide__slide', dataIndex: displayItems.length, onclick: `handleItemClick(${displayItems.length})`})
          if (gameSettings.border == 'thick') {
            el.classList.add('border')
          } else if (gameSettings.border == 'hairline'){
            el.classList.add('border')
            el.classList.add('border-hairline')
          } else if (gameSettings.border == 'rounded'){
            el.classList.add('border')
            el.classList.add('border-rounded')
          }

          let innerContainer = newElement('div', { class: 'inner-container' })

          let card

          let amURL = false
          if (item.length > 1 && gameSettings.openLink && isURL(item[1].text)) {
            card = newElement('a', { class: 'card' })
            amURL = true
            itemURL = item[1].text
            card.setAttribute('target', 'blank')
          } else {
            card = newElement('span', { class: 'card' }) // should behave similar to <a> without pretending to be a link
          }

          innerContainer.appendChild(card)

          let front = newElement('div', { class: 'front face' })

          if (item[0].hasOwnProperty('image') && item[0].image != null) {
            addImageToEl(front, item[0].image, item[0].text)
            setCardAspectRatio(card, item[0].image)
          } else {
            front.appendChild(newElement('div', { class: 'text' }, item[0].text))
            front.classList.add('text-only')
          }

          card.appendChild(front)

          let hasBack = false

          if (gameSettings.backMode != 'disabled' && (item.length > 1 && !amURL && (item[1].text != '' || item[1].hasOwnProperty('image') && item[1].image != null))) {
            let back = newElement('div', { class: 'back face', ariaHidden: true })
            el.hasOwnProperty('double-sided')
            hasBack = true
            if (item[1].hasOwnProperty('image') && item[1].image != null) {
              addImageToEl(back, item[1].image, item[1].text)
              // TO DO: adjust card aspect ratio? 
            } else {
              back.appendChild(newElement('div', { class: 'text' }, item[1].text))
              back.classList.add('text-only')
            }
            card.appendChild(back)
          }

          el.appendChild(innerContainer)

          splideList.appendChild(el)
          displayItems.push({ el: el, card: card, index: displayItems.length, isURL: amURL, href: itemURL, hasBack: hasBack, zIndexDelay: null })
        }        
      })

      // make it possible to click on links and also on code
      let links = Array.from(splideList.querySelectorAll('.face a'))
      links.forEach(link => {
          link.addEventListener('click', event => {
              event.stopPropagation();
          });
      });
      let codes = Array.from(splideList.querySelectorAll('.face code'))
      codes.forEach(code => {
        code.setAttribute('onclick', 'event.stopPropagation()')
      })

      splide.mount();
      restyleItems(0);

      if(gameSettings.picker){
        document.getElementById("pickButton").classList.remove('hidden')
      }

      // update visibility with a tiny delay to make sure everything has been set first, also font sizes
      setTimeout(updateVisibility,100)      
      if(gameSettings.autoAdjustFontSize){
        setTimeout(adjustFontSizes,100)        
        window.addEventListener('resize', adjustFontSizesOnResize)
      }
    }

    function updateSettingsFromURL(){
      let url = new URL(window.location.href)
      let params = new URLSearchParams(url.search);

      if(params.has('category')){
        gameSettings.categories = params.getAll('category')
      }
      if(params.has('sort')){
        gameSettings.sort = params.get('sort')
      }
      if(params.has('invertSort')){
        gameSettings.invertSort = params.get('invertSort') == 'true'
      } 
      if(params.has('color')){
        gameSettings.color = params.get('color')
      }
      if(params.has('border')){
        gameSettings.border = params.get('border')
      }
      if(params.has('backMode')){
        gameSettings.backMode = params.get('backMode')
      }
      if(params.has('autoAdvance')){
        gameSettings.autoAdvance = params.get('autoAdvance') == 'true'
      }
      if(params.has('autoAdvanceDelay')){
        gameSettings.autoAdvanceDelay = parseInt(params.get('autoAdvanceDelay'))
      }
      if(params.has('picker')){
        gameSettings.picker = params.get('picker') == 'true'
      }
      if(params.has('openLink')){
        gameSettings.openLink = params.get('openLink') == 'true'
      }
      if(params.has('navigation')){
        gameSettings.navigation = params.get('navigation') == 'true'
      }
      if(params.has('randomSequence')){
        gameSettings.randomSequence = params.get('randomSequence') == 'true'
      }
    }

    function setColorTheme(theme) {
            if (theme != 'default light') {
                document.documentElement.setAttribute('data-theme', theme.toLowerCase())
            } else {
                document.documentElement.removeAttribute('data-theme')
            }
        }

    function establishHeaderAndFooter() {
      let header = document.getElementById('header')
      let footer = document.getElementById('footer')

      if (gameSettings.header != '') {
        header.innerHTML = gameSettings.header
        header.classList.remove('hidden')
        document.body.classList.add('has-header')
      } else {
        header.classList.add('hidden')
      }

      if (gameSettings.footer != '') {
        footer.innerHTML = gameSettings.footer
        footer.classList.remove('hidden')
        document.body.classList.add('has-footer')
      } else {
        footer.classList.add('hidden')
      }
    }

    function establishLogo(){
      let logo = document.getElementById('logo')
      if (gameSettings.logo.toLowerCase() != 'none') {
        logo.innerHTML = gameSettings.logo
        logo.classList.remove('hidden')
        if(gameSettings.logo == 'hex'){
          addImageToEl(logo, icons.logo, 'hex logo')
        } else {
          addImageToEl(logo, gameFiles['custom_setting_select-import_logo'], 'logo')
        }
        if(gameSettings.logoLink != ''){
          logo.setAttribute('href', gameSettings.logoLink)
          logo.classList.add('logo-link')
        }
      } else {
        logo.classList.add('hidden')
      }
    }

    function adjustFontSizes(reset = false){
      let faces = Array.from(document.querySelectorAll('.face.text-only'))
      faces.forEach(face => {
        let text = face.querySelector('.text')
        let fontSize = gameSettings.fontSize/100    
        if(reset){
          text.style.fontSize = null
        }    
        while(text && (text.offsetWidth > face.offsetWidth || text.offsetHeight > face.offsetHeight) && fontSize >= 0.5){
          fontSize -= 0.25
          text.style.fontSize = fontSize + 'em'
        }
        console.log(`fontSize: ${fontSize}`)
      })
    }    

    function adjustFontSizesOnResize(){
      if(fontSizeAdjustDelay){
        clearTimeout(fontSizeAdjustDelay)
      }
      fontSizeAdjustDelay = setTimeout(adjustFontSizes, 500, true)
    }

    function sortDisplayItems(){
      

      if(gameSettings.sort == 'index'){
        // already sorted
          return
        }

      gameData.sort((a, b) =>{
        if(gameSettings.sort == 'front'){
          if((!gameSettings.invertSort && a[0].text < b[0].text) || (gameSettings.invertSort && a[0].text > b[0].text)){
            return -1
          }
        } else if (gameSettings.sort == 'back'){
          if((!gameSettings.invertSort && a[1].text < b[1].text) || (gameSettings.invertSort && a[1].text > b[1].text)){
            return -1
          }
        } else if (gameSettings.sort == 'from'){
          // compare from dates (3), but if they're the same look at the until dates (4)
          if(((!gameSettings.invertSort && a[2].datetime < b[2].datetime) || (gameSettings.invertSort && a[2].datetime > b[2].datetime)) ||
          (a[2].datetime == b[2].datetime && (!gameSettings.invertSort && a[3].datetime < b[3].datetime) || (gameSettings.invertSort && a[3].datetime > b[3].datetime))){
            return -1
          }
        } else if (gameSettings.sort == 'until'){
          // compare until dates (4), but if they're the same look at the for dates (3)
          if(((!gameSettings.invertSort && a[3].datetime < b[3].datetime) || (gameSettings.invertSort && a[3].datetime > b[3].datetime)) ||
          (a[3].datetime == b[3].datetime && (!gameSettings.invertSort && a[2].datetime < b[2].datetime) || (gameSettings.invertSort && a[2].datetime > b[2].datetime))){
            return -1
          }
        } else if (gameSettings.sort == 'random'){
          return Math.random() - 0.5
        }
      })      
    }

    function handleItemClick(index, event) {
        // Check if the click originated from an <a> or <code> tag
        const target = event.target;
        console.log(target)
        if (target.tagName === 'A' || target.tagName === 'CODE' || target.tagName === 'P' || /H\d/.test(target.tagName)) {
            return; // Ignore the click and let the default behavior occur
        }

        // Existing behavior
        if (gameSettings.navigation && splide.index != index) {
            splide.go(index);
        } else if (splide.index == index && displayItems[index].hasBack && gameSettings.backMode != 'autoUnder') {
            flipItem(displayItems[index].el);
        }
    }

    function handleKeyPress(event, element) {
      if (event.code == 'Space' || event.code == 'Enter') {
        let index = parseInt(element.getAttribute('data-index'))
        if (splide.index == index && displayItems[index].isURL) {
          window.open(displayItems[index].href);
        } else {
          element.click()
          void element.firstElementChild.offsetWidth // trigger reflow
        }

      }
    }

    function flipItem(element) {
      if (element.classList.contains('up')) {
        element.classList.add('down')
        element.classList.remove('up')
        element.querySelector('.back').setAttribute('aria-hidden', false)
      } else {
        element.classList.add('up')
        element.classList.remove('down')
        element.querySelector('.back').setAttribute('aria-hidden', true)
      }
      updateVisibility()
    }

    function unflipFlipped() {
      let flipped = Array.from(document.querySelectorAll('.down'))
      flipped.forEach(el => {
        el.classList.remove('down')
        // if(!item.classList.contains('left') && !item.classList.contains('right')){
        el.classList.add('up')
        el.querySelector('.back').setAttribute('aria-hidden', true)
        // }
      })
      updateVisibility()
    }

    function restyleItems(currentIndex) {
      unflipFlipped()
      displayItems.forEach((item, i) => {
        if (i < currentIndex) {
          item.el.classList.add('left')
          item.el.classList.remove('right')
          item.el.classList.remove('current')
          item.el.classList.remove('autoUnder')
          let back = item.el.querySelector('.back')          
          if(back){
            back.setAttribute('aria-hidden', true)
          }
          if(!gameSettings.navigation){
            item.el.setAttribute('tabindex',null) // remove focus from the item if not in navigation mode
          }
          if (item.isURL) {
            item.card.removeAttribute('href')
          }
        } else if (i > currentIndex) {
          item.el.classList.add('right')
          item.el.classList.remove('left')
          item.el.classList.remove('current')
          item.el.classList.remove('autoUnder')
              let back = item.el.querySelector('.back')
          if(back){
            back.setAttribute('aria-hidden', true)
          }
          if(!gameSettings.navigation){
            item.el.setAttribute('tabindex',null) // remove focus from the item if not in navigation mode
          }
          if (item.isURL) {
            item.card.removeAttribute('href')
          }
        } else {
          item.el.classList.remove('left')
          item.el.classList.remove('right')
          item.el.classList.add('up')
          item.el.classList.add('current')         
          let back = item.el.querySelector('.back')
          if(gameSettings.backMode == 'autoUnder'){
            item.el.classList.add('autoUnder')
            if(back){
            back.setAttribute('aria-hidden', false)
          } 
          } else {
            if(back){
            back.setAttribute('aria-hidden', true)
          } 
          }
          item.el.style.transform = null
          if(!gameSettings.navigation){
            item.el.setAttribute('tabindex','0') // add ability to focus on the item if not in navigation mode
          }
          if (item.isURL) {
            setTimeout(function () {
              item.card.setAttribute('href', item.href)
            }, 1) // to avoid trigger the url on first press, minor delay
          }
        }
      })
      let right = Array.from(document.querySelectorAll('.splide__slide.right'))
      let left = Array.from(document.querySelectorAll('.splide__slide.left'))
      updateZIndex()
      displayItems[currentIndex].el.style.zIndex = (right.length > left.length ? right.length + 1 : left.length + 1)

      scrollTextOnlyToTop(displayItems[currentIndex].el)
    }

    function unstyleItems() {
      displayItems.forEach(item => {
        item.el.style = null
      })
    }

    function scrollTextOnlyToTop(element){
      const textOnlyElements = element.querySelectorAll('.text-only');
      textOnlyElements.forEach(element => {
        element.scrollTop = -1000; // Ensure the scroll position is at the top
      });
    }

    function updateVisibility(){
      document.querySelectorAll('[aria-hidden="false"] a').forEach(el => el.removeAttribute('tabindex'))
      document.querySelectorAll('[aria-hidden="true"] a').forEach(el => el.setAttribute('tabindex',-1))      
    }

    function pickRandom() {
      let randomIndex = splide.index
      if (gameSettings.randomSequence) {
        if (displayItemSequence.length == 0) {
          displayItemSequence = Array.from(displayItems.map(item => item.index))
          do{
            displayItemSequence.shuffle()                 
          } while (displayItemSequence.lenghth > 0 && displayItemSequence[0] != splide.index && displayItems.length > 1)
        }
        randomIndex = displayItemSequence.pop()
      } else {
        do {
          randomIndex = Math.floor(Math.random() * displayItems.length)
        } while (randomIndex == splide.index && displayItems.length > 1)
      }

      splide.go(randomIndex)
    }

    function updateZIndex() {
      // previously we used a delay, but it doesn't look so good now… leaving the code here for now in case we go back
      const delay = window.matchMedia('prefers-reduced-motion').matches ? 0 : 0 // no delay if reduced motion (TO DO: get automatically from speed)
      var zIndexClimber = 1000
      displayItems.forEach(displayItem => {
        if (displayItem.el.classList.contains('right')) {  // if on the right, zIndex goes down                
          zIndexClimber--
        } else { // if on the left-hand side, or center, zIndex climbs up
          zIndexClimber++
        }
        // set zindex with slight delay (looks better on animation)
        clearTimeout(displayItem.zIndexDelay)

        displayItem.zIndexDelay = setTimeout(setZ, delay, displayItem.el, zIndexClimber)
      })
    }

    function setZ(el, value) {
      el.style.zIndex = value
    }



    function addImageToEl(el, image, text = '') {
      if (image.ext == 'svg') {
        el.innerHTML = atob(image.data)
        el.firstElementChild.alt = text
      } else {
        // el.style.backgroundImage = 'url("data:image/' + image.ext + ';base64,' + image.data + '")'
        let imgEl = newElement('img', { src: 'data:image/' + image.ext + ';base64,' + image.data, alt: text })
        el.appendChild(imgEl)
      }            
    }

    // adapted from https://www.svgbackgrounds.com/tools/svg-to-css/
    function modern_SVG2CSS(SVG_input) {
      var safe_svg = SVG_input.replace('width="100%"', '') // remove width property
        .replace(/#/g, "%23")
        .replace(/\?/g, "%3F") //probably don't have ? marks in SVG		
        .replace(/[\t\n\r]/gm, '') //remove tabs and new lines
        .replace(/\s\s+/g, ' ') //replace multiple spaces with a single space
        .replace(/'/g, '"') //replace single quotes with double
        .replace(/> </g, '><');

      return "url('data:image/svg+xml," + safe_svg + "')";
      //new approach: https://www.youtube.com/watch?v=6qSN50Qk_54	
    }

    function setCardAspectRatio(card, image) {

      const aspectRatio = image.dimensions.width / image.dimensions.height; // Calculate aspect ratio
      let faces = Array.from(card.querySelectorAll('.face'))

      // Apply aspect ratio dynamically
      card.style.aspectRatio = aspectRatio;
      // card.style.maxWidth = image.dimensions.width + 'px'
      faces.forEach(face => {
        face.style.aspectRatio = aspectRatio;
        // face.style.maxHeight = image.dimensions.width + 'px'
      })


    }

    function isFutureDate(dateTimeString) {
      try {
        const dateTime = convertToDateTime(dateTimeString); // Use the function to convert
        const now = new Date(); // Get the current time
        return dateTime > now; // Return true if dateTime is in the future
      } catch (error) {
        console.error(error.message);
        return false; // Return false if there's an error
      }
    }

    function isPastDate(dateTimeString) {
      try {
        const dateTime = convertToDateTime(dateTimeString); // Use the function to convert
        const now = new Date(); // Get the current time
        return dateTime < now; // Return true if dateTime is in the future
      } catch (error) {
        console.error(error.message);
        return false; // Return false if there's an error
      }
    }

    function convertToDateTime(dateTimeString) {
      // Parse the string and create a new Date object
      const dateObject = new Date(dateTimeString);

      // Check if the resulting date is valid
      if (isNaN(dateObject.getTime())) {
        throw new Error("Invalid date string format");
      }

      return dateObject;
    }

    function isURL(string) {
      let regex = /https?:\/\/(www\.)?[-a-zA-Z0-9@:%._\+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b([-a-zA-Z0-9()@:%_\+.~#?&//=]*)/g
      return regex.test(string)
    }

    Array.prototype.shuffle = function () {
      let currentIndex = this.length, randomIndex;

      // While there remain elements to shuffle.
      while (currentIndex > 0) {

        // Pick a remaining element.
        randomIndex = Math.floor(Math.random() * currentIndex);
        currentIndex--;

        // And swap it with the current element.
        [this[currentIndex], this[randomIndex]] = [
          this[randomIndex], this[currentIndex]];
      }
      return this
    }

    function newElement(tag, properties = {}, innerHTML = '') {
      let el = document.createElement(tag)
      for (const property in properties) {
        let propertyName = property.replaceAll(/([A-Z])/g, '-$1').toLowerCase() // change camel case to - seperation
        el.setAttribute(propertyName, properties[property])
      }
      if (typeof innerHTML == 'string') {
        el.innerHTML = innerHTML
      } else {
        el.appendChild(innerHTML)
      }
      return el
    }

  </script>
  <script>
    icons = {
      logo: {
        ext: 'svg',
        data: 'PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+Cjxzdmcgd2lkdGg9IjEwMCUiIGhlaWdodD0iMTAwJSIgdmlld0JveD0iMCAwIDEwMjQgMTAyMCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4bWw6c3BhY2U9InByZXNlcnZlIiB4bWxuczpzZXJpZj0iaHR0cDovL3d3dy5zZXJpZi5jb20vIiBzdHlsZT0iZmlsbC1ydWxlOmV2ZW5vZGQ7Y2xpcC1ydWxlOmV2ZW5vZGQ7c3Ryb2tlLWxpbmVqb2luOnJvdW5kO3N0cm9rZS1taXRlcmxpbWl0OjI7Ij4KICAgIDxnIHRyYW5zZm9ybT0ibWF0cml4KDAuOTkwMTY5LDAsMCwwLjk5MDE2OSwtNTAxLjkzMywtMjUwLjYxMykiPgogICAgICAgIDxlbGxpcHNlIGN4PSI5MTAuMTgzIiBjeT0iNzU0LjU1MiIgcng9IjExMi4yNDciIHJ5PSIxLjAwMyIgc3R5bGU9ImZpbGw6cmdiKDIzNSwyMzUsMjM1KTsiLz4KICAgIDwvZz4KICAgIDxnIHRyYW5zZm9ybT0ibWF0cml4KDEuMDEzNTcsMCwwLDEuMDEzNTcsLTIuMzUwMjMsLTYuOTIwODYpIj4KICAgICAgICA8cGF0aCBkPSJNMy45NjQsNTAzLjYzNkMxLjc1Nyw1MDcuNDc1IDEuNzU3LDUxMi4xOTggMy45NjQsNTE2LjAzN0MzLjk2NCw1MTYuMDM3IDg2LjMyMiw2NTMuNzA0IDE1Ny4yNTQsNzczLjE2N0MyMTEuNDAyLDg2NC4zNjMgMjU4LjgzNCw5NDQuOTQgMjU4LjgzNCw5NDQuOTRDMjU5Ljc2OSw5NDYuNTY1IDI2MS41LDk0Ny41NjcgMjYzLjM3NSw5NDcuNTY3QzI2My4zNzUsOTQ3LjU2NyA0MjMuMjY4LDk0NS45NiA1NjEuNzI1LDk0NS4xNjZDNjY3LjQyNSw5NDQuNTU5IDc2MC42MjUsOTQ0LjQ4NSA3NjAuNjI1LDk0NC40ODVDNzYxLjM5Nyw5NDQuNDg1IDc2Mi4xMDksOTQ0LjA3MyA3NjIuNDk0LDk0My40MDRMMTAxMi4xNCw1MTEuNDk4QzEwMTIuNzMsNTEwLjQ2OSAxMDEyLjczLDUwOS4yMDQgMTAxMi4xNCw1MDguMTc1TDc2NS43MjYsNzQuNDExQzc2NC42NzYsNzIuNTg1IDc2Mi43MzEsNzEuNDYgNzYwLjYyNSw3MS40NkwyNjMuMzc1LDY4LjMyNUMyNjAuMTQ3LDY4LjMyNSAyNTcuMTY1LDcwLjA1MSAyNTUuNTU3LDcyLjg0OUwzLjk2NCw1MDMuNjM2Wk0yOS4wMDEsNTA5LjkxMkwyNjguNjUzLDg2LjMyOEMzMTkuMTg5LDg2LjAxIDcxNi41MDMsODMuNTA1IDc1Ny4yNTMsODMuMjQ4Qzc1Ny4yNTMsODMuMjQ4IDk4OC42MjcsNDgxLjAxMyAxMDA1LjQsNTA5Ljg1MUMxMDA1LjQsNTA5Ljg1MSA3NTkuMzc1LDk0MC4xNzMgNzU5LjM3NSw5NDAuMTczQzc0Ny45ODIsOTQwLjE2MiA2NjAuMjg4LDk0MC4wNTkgNTYxLjcyNSw5MzkuNDkzQzQzNC41NDUsOTM4Ljc2NCAyODkuMjc5LDkzNy4zNDggMjY2LjQ1OSw5MzcuMTIzQzI1OC4yNzcsOTIyLjUzNyAyMTYuNzYsODQ4LjQ4NiAxNzAuNTk2LDc2NS40OThDMTExLjUwMiw2NTkuMjY2IDQ0Ljc2Nyw1MzguNDYzIDI5LjAwMSw1MDkuOTEyTDI5LjAwMSw1MDkuOTEyWiIvPgogICAgPC9nPgogICAgPGcgdHJhbnNmb3JtPSJtYXRyaXgoMi4yODI0NCwwLDAsMi4yODI0NCwtMTU3Ni44NSwtMTE2Mi44NykiPgogICAgICAgIDx0ZXh0IHg9Ijc1MC41ODVweCIgeT0iODA2LjE5NHB4IiBzdHlsZT0iZm9udC1mYW1pbHk6J1NoYXJlVGVjaC1SZWd1bGFyJywgJ1NoYXJlIFRlY2gnO2ZvbnQtc2l6ZToyNTEuMTkzcHg7Ij5oPHRzcGFuIHg9Ijg2MS4zNjFweCA5NjMuMzQ2cHggIiB5PSI4MDYuMTk0cHggODA2LjE5NHB4ICI+ZXg8L3RzcGFuPjwvdGV4dD4KICAgIDwvZz4KPC9zdmc+Cg==',
        dimensions: {height: 1024,width: 1020,type: 'svg'},
        fileSize: 1900
      }
    }
  </script>
</head>

<body>
  <a id="logo" class="logo"></a>
  <div class="fade fade-left"></div>
  <div class="fade fade-right"></div>
  <div id="header" class="header hidden"></div>
  <button id="pickButton" class="pick-button hidden" onclick="pickRandom()">Random</button>
  <section id="displayCase" class="splide">
    <div id="splideTrack" class="splide__track" onmouseenter="hovering=true" onmouseleave="hovering=false"></div>
  </section>
  <div id="footer" class="footer footer"></div>
</body>

<script src="activityController.js"></script>
<!--This space is for either the activityController (when running in electron) or the game data (after export) -->

</html>